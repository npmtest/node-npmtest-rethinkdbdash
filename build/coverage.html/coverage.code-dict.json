{"/home/travis/build/npmtest/node-npmtest-rethinkdbdash/test.js":"/* istanbul instrument in package npmtest_rethinkdbdash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/lib.npmtest_rethinkdbdash.js":"/* istanbul instrument in package npmtest_rethinkdbdash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_rethinkdbdash = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_rethinkdbdash = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-rethinkdbdash && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_rethinkdbdash */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_rethinkdbdash\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_rethinkdbdash.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_rethinkdbdash.rollup.js'] =\n            local.assetsDict['/assets.npmtest_rethinkdbdash.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_rethinkdbdash.__dirname + '/lib.npmtest_rethinkdbdash.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/index.js":"var Promise = require('bluebird');\n\nvar helper = require(__dirname+'/helper.js');\nvar Connection = require(__dirname+'/connection.js');\nvar Term = require(__dirname+'/term.js');\nvar Error = require(__dirname+'/error.js');\nvar PoolMaster = require(__dirname+'/pool_master.js');\nvar termTypes = require(__dirname+'/protodef.js').Term.TermType;\n\nfunction r() {\n  var self = this;\n  var _r = function(x) {\n    return new Term(_r).expr(x);\n  }\n  helper.changeProto(_r, self);\n\n  Term.prototype._setNestingLevel(r.prototype.nestingLevel);\n  Term.prototype._setArrayLimit(r.prototype.arrayLimit);\n\n  _r.row = new Term(_r).row();\n\n  _r.monday = new Term(_r).monday();\n  _r.tuesday = new Term(_r).tuesday();\n  _r.wednesday = new Term(_r).wednesday();\n  _r.thursday = new Term(_r).thursday();\n  _r.friday = new Term(_r).friday();\n  _r.saturday = new Term(_r).saturday();\n  _r.sunday =  new Term(_r).sunday();\n\n  _r.january = new Term(_r).january();\n  _r.february = new Term(_r).february();\n  _r.march = new Term(_r).march();\n  _r.april = new Term(_r).april();\n  _r.may = new Term(_r).may();\n  _r.june = new Term(_r).june();\n  _r.july = new Term(_r).july();\n  _r.august = new Term(_r).august();\n  _r.september = new Term(_r).september();\n  _r.october = new Term(_r).october();\n  _r.november = new Term(_r).november();\n  _r.december = new Term(_r).december();\n  _r.minval = new Term(_r).minval();\n  _r.maxval = new Term(_r).maxval();\n\n  _r.nextVarId = 1;\n  _r._Term = Term;\n  return _r;\n};\nr.prototype._host = 'localhost';\nr.prototype._port = 28015;\nr.prototype._authKey = '';\nr.prototype._user = 'admin';\nr.prototype._password = '';\nr.prototype._timeoutConnect = 20; // seconds\nr.prototype._pingInterval = -1; // seconds\n\nr.prototype._nestingLevel = 100;\nr.prototype._arrayLimit = 100000;\nr.prototype._db = 'test';\nr.prototype._useOutdated = false;\nr.prototype._timeFormat = 'native';\nr.prototype._profile = false;\n\n\nr.prototype.setNestingLevel = function(nestingLevel) {\n  if (typeof nestingLevel !== 'number') throw new Error.ReqlDriverError('The first argument of `setNestingLevel` must be a number.')\n  this.nestingLevel = nestingLevel;\n}\nr.prototype.setArrayLimit = function(arrayLimit) {\n  if (typeof arrayLimit !== 'number') throw new Error.ReqlDriverError('The first argument of `setArrayLimit` must be a number.')\n  this.arrayLimit = arrayLimit;\n}\n\nr.prototype.connect = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n\n  var p = new Promise(function(resolve, reject) {\n    new Connection(self, options, resolve, reject);\n  }).nodeify(callback);\n  return p;\n};\n\nr.prototype.createPools = function(options) {\n  this._poolMaster = new PoolMaster(this, options);\n  return this;\n}\n\nr.prototype.getPoolMaster = function() {\n  return this._poolMaster;\n}\nr.prototype.getPool = function(i) {\n  if (i === undefined) {\n    if (this.getPoolMaster().getPools().length === 1) {\n      return this.getPoolMaster().getPools()[0];\n    }\n    else {\n      throw new Error('You have multiple pools. Use `getPool(index)` or `getPools()`');\n    }\n  }\n  else {\n    return this.getPoolMaster().getPools()[i];\n  }\n}\n\nr.prototype.expr = function(expression, nestingLevel) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'expr', this);\n  }\n  var _nestingLevel = nestingLevel || this.nestingLevel;\n  return new Term(this).expr(expression, _nestingLevel);\n};\nr.prototype.db = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.db', this);\n  }\n  return new Term(this).db(db);\n};\nr.prototype.table = function(table, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'table', this);\n  }\n  return new Term(this).table(table, options);\n};\nr.prototype.js = function(jsString, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.js', this);\n  }\n  return new Term(this).js(jsString, options);\n};\nr.prototype.tableCreate = function(table, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.tableCreate', this);\n  }\n  return new Term(this).tableCreate(table, options);\n};\nr.prototype.tableDrop = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.tableDrop', this);\n  }\n  return new Term(this).tableDrop(db);\n};\nr.prototype.tableList = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'r.tableList', this);\n  }\n  return new Term(this).tableList();\n};\nr.prototype.dbCreate = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'dbCreate', this);\n  }\n  return new Term(this).dbCreate(db);\n};\nr.prototype.dbDrop = function(db) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'dbDrop', this);\n  }\n  return new Term(this).dbDrop(db);\n};\nr.prototype.dbList = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'dbList', this);\n  }\n  return new Term(this).dbList();\n};\nr.prototype.literal = function(obj) {\n  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.literal', this);\n  }\n  if (obj === undefined) {\n    return new Term(this).literal();\n  }\n  else {\n    return new Term(this).literal(obj);\n  }\n};\nr.prototype.desc = function(field) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.desc', this);\n  }\n  return new Term(this).desc(field);\n};\nr.prototype.asc = function(field) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.asc', this);\n  }\n  return new Term(this).asc(field);\n};\nr.prototype.union = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this).expr(_args[0]);\n  return term.union.apply(term, _args.slice(1));\n};\nr.prototype.add = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.add', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.add.apply(term, _args.slice(1));\n};\nr.prototype.sub = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.sub', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.sub.apply(term, _args.slice(1));\n};\nr.prototype.div = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.div', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.div.apply(term, _args.slice(1));\n};\nr.prototype.mul = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.mul', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.mul.apply(term, _args.slice(1));\n};\nr.prototype.mod = function(a, b) {\n  if (Term.prototype._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 2, 'r.mod', this);\n  }\n\n  return new Term(this).expr(a).mod(b);\n};\nr.prototype.and = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this);\n  return term.and.apply(term, _args);\n};\nr.prototype.or = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this);\n  return term.or.apply(term, _args);\n};\nr.prototype.eq = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.eq', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.eq.apply(term, _args.slice(1));\n};\nr.prototype.ne = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.ne', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.ne.apply(term, _args.slice(1));\n};\nr.prototype.gt = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.gt', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.gt.apply(term, _args.slice(1));\n};\nr.prototype.ge = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.ge', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.ge.apply(term, _args.slice(1));\n};\nr.prototype.lt = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.lt', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.lt.apply(term, _args.slice(1));\n};\nr.prototype.le = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.le', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.le.apply(term, _args.slice(1));\n};\nr.prototype.not = function(bool) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.not', this);\n  }\n  return new Term(this).expr(bool).not();\n}\nr.prototype.floor = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.floor', this);\n  }\n  return new Term(this).expr(num).floor();\n}\nr.prototype.ceil = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.ceil', this);\n  }\n  return new Term(this).expr(num).ceil();\n}\nr.prototype.round = function(num) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.round', this);\n  }\n  return new Term(this).expr(num).round();\n}\n\n\nr.prototype.now = function() {\n  if (Term.prototype._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 0, 'now', this);\n  }\n  return new Term(this).now();\n}\nr.prototype.time = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.time.apply(term, _args);\n}\nr.prototype.epochTime = function(epochTime) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.epochTime', this);\n  }\n  return new Term(this).epochTime(epochTime);\n}\nr.prototype.ISO8601 = function(isoTime, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 1, 2, 'r.ISO8601', this);\n  }\n  return new Term(this).ISO8601(isoTime, options);\n}\nr.prototype.branch = function(predicate, trueBranch, falseBranch) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 3, Infinity, 'r.branch', this);\n\n  var term = new Term(this).expr(predicate);\n  return term.branch.apply(term, _args.slice(1));\n}\nr.prototype.error = function(errorStr) {\n  if (Term.prototype._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 0, 1, 'r.error', this);\n  }\n  var term = new Term(this);\n  term._query.push(termTypes.ERROR);\n  if (errorStr !== undefined) {\n    term._query.push([new Term(this).expr(errorStr)._query]);\n  }\n  return term;\n\n}\nr.prototype.json = function(json) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.json', this);\n  }\n  return new Term(this).json(json);\n}\n\nr.prototype.object = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.object.apply(term, _args);\n}\nr.prototype.args = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.args.apply(term, _args);\n}\nr.prototype.random = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.random.apply(term, _args);\n}\nr.prototype.http = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this);\n  return term.http.apply(term, _args);\n}\nr.prototype.do = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.do', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.do.apply(term, _args.slice(1));\n}\nr.prototype.binary = function(bin) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.binary', this);\n  }\n  var term = new Term(this);\n  return term.binary(bin);\n}\nr.prototype.uuid = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 0, 1, 'r.uuid', this);\n  var term = new Term(this);\n  return term.uuid(_args[0]);\n}\n\nr.prototype.line = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, Infinity, 'r.line', this);\n\n  var term = new Term(this);\n  return term.line.apply(term, _args);\n}\nr.prototype.point = function(longitude, latitude) {\n  if (Term.prototype._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 2, 'r.point', this);\n  }\n  return new Term(this).point(longitude, latitude);\n}\nr.prototype.polygon = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 3, Infinity, 'r.polygon', this);\n\n  var term = new Term(this);\n  return term.polygon.apply(term, _args);\n}\nr.prototype.circle = function(center, radius, options) {\n  if (Term.prototype._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arityRange(_args, 2, 3, 'r.circle', this);\n  }\n  var term = new Term(this);\n  if (options !== undefined) {\n    return term.circle(center, radius, options);\n  }\n  else {\n    return term.circle(center, radius);\n  }\n}\nr.prototype.geojson = function(value) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.geojson', this);\n  }\n  var term = new Term(this);\n  return term.geojson(value);\n}\nr.prototype.distance = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 2, 3, 'r.add', this);\n\n  var term = new Term(this).expr(_args[0]);\n  return term.distance.apply(term, _args.slice(1));\n};\n\nr.prototype.range = function(start, end) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, 2, 'r.range', this);\n\n  var term = new Term(this);\n  if (end !== undefined) {\n    return term.range(start, end);\n  }\n  else {\n    return term.range(start);\n  }\n}\nr.prototype.wait = function() {\n  // `wait` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`wait` can only be called on a table or a database since 2.3');\n}\nr.prototype.reconfigure = function(config) {\n  // `reconfigure` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`reconfigure` can only be called on a table or a database since 2.3');\n}\nr.prototype.rebalance = function(config) {\n  // `rebalance` on the top level has been removed in 2.3.\n  throw new Error.ReqlDriverError('`rebalance` can only be called on a table or a database since 2.3');\n}\nr.prototype.map = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.map', this);\n\n  var term = new Term(this);\n  return term.map.apply(term, _args);\n};\nr.prototype.typeOf = function(value) {\n  if (Term.prototype._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    Term.prototype._arity(_args, 1, 'r.typeOf', this);\n  }\n  var term = new Term(this);\n  return term.expr(value).typeOf();\n}\nr.prototype.min = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.min', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.min.apply(term, _args.slice(1));\n}\nr.prototype.max = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.max', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.max.apply(term, _args.slice(1));\n}\nr.prototype.sum = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.sum', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.sum.apply(term, _args.slice(1));\n}\nr.prototype.avg = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.avg', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.avg.apply(term, _args.slice(1));\n}\nr.prototype.distinct = function(value) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  Term.prototype._arityRange(_args, 1, Infinity, 'r.distinct', this);\n  var term = new Term(this).expr(_args[0]);\n  return term.distinct.apply(term, _args.slice(1));\n}\n\n\nr.prototype.Error = Error;\n\n\nfunction main(options) {\n  var _r = new r();\n\n  if (!helper.isPlainObject(options)) options = {};\n  if (options.pool !== false) _r.createPools(options);\n  _r._options = {};\n  if (options.cursor === true) _r._options.cursor = true;\n  if (options.stream === true) _r._options.stream = true;\n  if (options.optionalRun === false) {\n    delete _r._Term.prototype.then\n    delete _r._Term.prototype.error\n    delete _r._Term.prototype.catch\n    delete _r._Term.prototype.finally\n  }\n  return _r;\n}\nmodule.exports = main;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/helper.js":"var protodef = require(__dirname+'/protodef.js');\nvar termTypes = protodef.Term.TermType;\nvar datumTypes = protodef.Datum.DatumType;\nvar net = require('net');\n\n\nfunction createLogger(poolMaster, silent) {\n  return function(message) {\n    if (silent !== true) {\n      console.error(message);\n    }\n    poolMaster.emit('log', message);\n  }\n}\nmodule.exports.createLogger = createLogger;\n\nfunction isPlainObject(obj) {\n  return Object.prototype.toString.call(obj) === '[object Object]';\n}\nmodule.exports.isPlainObject = isPlainObject;\n\nfunction toArray(args) {\n  return Array.prototype.slice.call(args);\n}\nmodule.exports.toArray = toArray;\n\nfunction hasImplicit(arg) {\n  if (Array.isArray(arg)) {\n    if (arg[0] === termTypes.IMPLICIT_VAR) return true;\n\n    if (Array.isArray(arg[1])) {\n      for(var i=0; i<arg[1].length; i++) {\n        if (hasImplicit(arg[1][i])) return true;\n      }\n    }\n    if (isPlainObject(arg[2])) {\n      for(var key in arg[2]) {\n        if (hasImplicit(arg[2][key])) return true;\n      }\n    }\n  }\n  else if (isPlainObject(arg)) {\n    for(var key in arg) {\n      if (hasImplicit(arg[key])) return true;\n    }\n  }\n  return false;\n}\nmodule.exports.hasImplicit = hasImplicit;\n\nfunction loopKeys(obj, fn) {\n  var keys = Object.keys(obj);\n  var result;\n  var keysLength = keys.length;\n  for(var i=0; i<keysLength; i++) {\n    result = fn(obj, keys[i]);\n    if (result === false) return;\n  }\n}\nmodule.exports.loopKeys = loopKeys;\n\nfunction convertPseudotype(obj, options) {\n  var reqlType = obj['$reql_type$'];\n  if (reqlType === 'TIME' && options['timeFormat'] !== 'raw') {\n    return new Date(obj['epoch_time'] * 1000);\n  }\n  else if (reqlType === 'GROUPED_DATA' && options['groupFormat'] !== 'raw') {\n    var result = [];\n    for (var i = 0, len = obj['data'].length, ref; i < len; i++) {\n      ref = obj.data[i];\n      result.push({\n        group: ref[0],\n        reduction: ref[1]\n      });\n    }\n    return result;\n  }\n  else if (reqlType === 'BINARY' && options['binaryFormat'] !== 'raw') {\n    return new Buffer(obj['data'], 'base64');\n  }\n  return obj;\n}\nfunction recursivelyConvertPseudotype(obj, options) {\n  var i, value, len, key;\n  if (Array.isArray(obj)) {\n    for (i = 0, len = obj.length; i < len; i++) {\n      value = obj[i];\n      obj[i] = recursivelyConvertPseudotype(value, options);\n    }\n  }\n  else if (obj && typeof obj === 'object') {\n    for (key in obj) {\n      value = obj[key];\n      obj[key] = recursivelyConvertPseudotype(value, options);\n    }\n    obj = convertPseudotype(obj, options);\n  }\n  return obj;\n}\nfunction makeAtom(response, options) {\n  options = options || {};\n  return recursivelyConvertPseudotype(response.r[0], options);\n}\nmodule.exports.makeAtom = makeAtom;\n\nfunction makeSequence(response, options) {\n  options = options || {};\n  return recursivelyConvertPseudotype(response.r, options);\n}\n\nmodule.exports.makeSequence = makeSequence;\n\nfunction changeProto(object, other) {\n  object.__proto__ = other.__proto__;\n}\nmodule.exports.changeProto = changeProto;\n\n// Try to extract the most global address\n// Note: Mutate the input\nfunction getCanonicalAddress(addresses) {\n  // We suppose that the addresses are all valid, and therefore use loose regex\n  for(var i=0; i<addresses.length; i++) {\n    var addresse = addresses[i];\n    if ((/^127(\\.\\d{1,3}){3}$/.test(addresse.host)) || (/0?:?0?:?0?:?0?:?0?:?0?:0?:1/.test(addresse.host))) {\n      addresse.value = 0;\n    }\n    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[eE]80:.*\\:.*\\:/.test(addresse.host))) {\n      addresse.value = 1;\n    }\n    else if (/^169\\.254\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 2;\n    }\n    else if (/^192\\.168\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 3;\n    }\n    else if (/^172\\.(1\\d|2\\d|30|31)\\.\\d{1,3}\\.\\d{1,3}$/.test(addresse.host)) {\n      addresse.value = 4;\n    }\n    else if (/^10(\\.\\d{1,3}){3}$/.test(addresse.host)) {\n      addresse.value = 5;\n    }\n    else if ((net.isIPv6(addresse.host)) && (/^[fF]|[cCdD].*\\:.*\\:/.test('addresse.host'))) {\n      addresse.value = 6;\n    }\n    else {\n      addresse.value = 7;\n    }\n  }\n  var result = addresses[0];\n  var max = addresses[0].value;\n  for(var i=0; i<addresses.length; i++) {\n    if (addresses[i].value > max) {\n      result = addresses[i];\n      max = addresses[i].value;\n    }\n  }\n  return result;\n}\nmodule.exports.getCanonicalAddress = getCanonicalAddress;\n\n\nmodule.exports.localhostAliases = {\n  'localhost': true,\n  '127.0.0.1': true,\n  '::1': true\n}\n\nmodule.exports.tryCatch = function tryCatch(toTry, handleError) {\n  try{\n  toTry()\n  }\n  catch(err) {\n  handleError(err)\n  }\n}\n\nfunction splitCommaEqual(message) {\n  var result = {};\n  var messageParts = message.split(',');\n  for(var i=0; i<messageParts.length; i++) {\n    var equalPosition = messageParts[i].indexOf(\"=\")\n    result[messageParts[i].slice(0, equalPosition)] = messageParts[i].slice(equalPosition+1);\n  }\n  return result;\n}\nmodule.exports.splitCommaEqual = splitCommaEqual;\n\nfunction xorBuffer(a, b) {\n  var result = [];\n  var len = Math.min(a.length, b.length)\n  for(var i=0; i<len; i++) {\n    result.push(a[i] ^ b[i]);\n  }\n  return new Buffer(result);\n}\nmodule.exports.xorBuffer = xorBuffer;\n\nfunction compareDigest(a, b) {\n  var left = undefined\n  var right = b\n  var result = undefined\n  if (a.length === b.length) {\n    left = a\n    result = 0\n  } else {\n    left = b\n    result = 1\n  }\n  var len = Math.min(a.length, b.length);\n  for(var i=0; i<len; i++) {\n    result |= a[i] ^b[i]\n  }\n  return result === 0\n}\nmodule.exports.compareDigest = compareDigest;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/protodef.js":"// DO NOT EDIT\n// Autogenerated by convert_protofile\n\nmodule.exports = {\n\tVersionDummy: {\n\t\tVersion: {\n\t\t\tV0_1: 1063369270,\n\t\t\tV0_2: 1915781601,\n\t\t\tV0_3: 1601562686,\n\t\t\tV0_4: 1074539808,\n\t\t\tV1_0: 885177795\n\t\t},\n\t\t\n\t\tProtocol: {\n\t\t\tPROTOBUF: 656407617,\n\t\t\tJSON: 2120839367\n\t\t}\n\t},\n\t\n\tQuery: {\n\t\tQueryType: {\n\t\t\tSTART: 1,\n\t\t\tCONTINUE: 2,\n\t\t\tSTOP: 3,\n\t\t\tNOREPLY_WAIT: 4,\n\t\t\tSERVER_INFO: 5\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t},\n\t\n\tFrame: {\n\t\tFrameType: {\n\t\t\tPOS: 1,\n\t\t\tOPT: 2\n\t\t}\n\t},\n\t\n\tBacktrace: {},\n\t\n\tResponse: {\n\t\tResponseType: {\n\t\t\tSUCCESS_ATOM: 1,\n\t\t\tSUCCESS_SEQUENCE: 2,\n\t\t\tSUCCESS_PARTIAL: 3,\n\t\t\tWAIT_COMPLETE: 4,\n\t\t\tSERVER_INFO: 5,\n\t\t\tCLIENT_ERROR: 16,\n\t\t\tCOMPILE_ERROR: 17,\n\t\t\tRUNTIME_ERROR: 18\n\t\t},\n\t\t\n\t\tErrorType: {\n\t\t\tINTERNAL: 1000000,\n\t\t\tRESOURCE_LIMIT: 2000000,\n\t\t\tQUERY_LOGIC: 3000000,\n\t\t\tNON_EXISTENCE: 3100000,\n\t\t\tOP_FAILED: 4100000,\n\t\t\tOP_INDETERMINATE: 4200000,\n\t\t\tUSER: 5000000,\n\t\t\tPERMISSION_ERROR: 6000000\n\t\t},\n\t\t\n\t\tResponseNote: {\n\t\t\tSEQUENCE_FEED: 1,\n\t\t\tATOM_FEED: 2,\n\t\t\tORDER_BY_LIMIT_FEED: 3,\n\t\t\tUNIONED_FEED: 4,\n\t\t\tINCLUDES_STATES: 5\n\t\t}\n\t},\n\t\n\tDatum: {\n\t\tDatumType: {\n\t\t\tR_NULL: 1,\n\t\t\tR_BOOL: 2,\n\t\t\tR_NUM: 3,\n\t\t\tR_STR: 4,\n\t\t\tR_ARRAY: 5,\n\t\t\tR_OBJECT: 6,\n\t\t\tR_JSON: 7\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t},\n\t\n\tTerm: {\n\t\tTermType: {\n\t\t\tDATUM: 1,\n\t\t\tMAKE_ARRAY: 2,\n\t\t\tMAKE_OBJ: 3,\n\t\t\tVAR: 10,\n\t\t\tJAVASCRIPT: 11,\n\t\t\tUUID: 169,\n\t\t\tHTTP: 153,\n\t\t\tERROR: 12,\n\t\t\tIMPLICIT_VAR: 13,\n\t\t\tDB: 14,\n\t\t\tTABLE: 15,\n\t\t\tGET: 16,\n\t\t\tGET_ALL: 78,\n\t\t\tEQ: 17,\n\t\t\tNE: 18,\n\t\t\tLT: 19,\n\t\t\tLE: 20,\n\t\t\tGT: 21,\n\t\t\tGE: 22,\n\t\t\tNOT: 23,\n\t\t\tADD: 24,\n\t\t\tSUB: 25,\n\t\t\tMUL: 26,\n\t\t\tDIV: 27,\n\t\t\tMOD: 28,\n\t\t\tFLOOR: 183,\n\t\t\tCEIL: 184,\n\t\t\tROUND: 185,\n\t\t\tAPPEND: 29,\n\t\t\tPREPEND: 80,\n\t\t\tDIFFERENCE: 95,\n\t\t\tSET_INSERT: 88,\n\t\t\tSET_INTERSECTION: 89,\n\t\t\tSET_UNION: 90,\n\t\t\tSET_DIFFERENCE: 91,\n\t\t\tSLICE: 30,\n\t\t\tSKIP: 70,\n\t\t\tLIMIT: 71,\n\t\t\tOFFSETS_OF: 87,\n\t\t\tCONTAINS: 93,\n\t\t\tGET_FIELD: 31,\n\t\t\tKEYS: 94,\n\t\t\tVALUES: 186,\n\t\t\tOBJECT: 143,\n\t\t\tHAS_FIELDS: 32,\n\t\t\tWITH_FIELDS: 96,\n\t\t\tPLUCK: 33,\n\t\t\tWITHOUT: 34,\n\t\t\tMERGE: 35,\n\t\t\tBETWEEN_DEPRECATED: 36,\n\t\t\tBETWEEN: 182,\n\t\t\tREDUCE: 37,\n\t\t\tMAP: 38,\n\t\t\tFOLD: 187,\n\t\t\tFILTER: 39,\n\t\t\tCONCAT_MAP: 40,\n\t\t\tORDER_BY: 41,\n\t\t\tDISTINCT: 42,\n\t\t\tCOUNT: 43,\n\t\t\tIS_EMPTY: 86,\n\t\t\tUNION: 44,\n\t\t\tNTH: 45,\n\t\t\tBRACKET: 170,\n\t\t\tINNER_JOIN: 48,\n\t\t\tOUTER_JOIN: 49,\n\t\t\tEQ_JOIN: 50,\n\t\t\tZIP: 72,\n\t\t\tRANGE: 173,\n\t\t\tINSERT_AT: 82,\n\t\t\tDELETE_AT: 83,\n\t\t\tCHANGE_AT: 84,\n\t\t\tSPLICE_AT: 85,\n\t\t\tCOERCE_TO: 51,\n\t\t\tTYPE_OF: 52,\n\t\t\tUPDATE: 53,\n\t\t\tDELETE: 54,\n\t\t\tREPLACE: 55,\n\t\t\tINSERT: 56,\n\t\t\tDB_CREATE: 57,\n\t\t\tDB_DROP: 58,\n\t\t\tDB_LIST: 59,\n\t\t\tTABLE_CREATE: 60,\n\t\t\tTABLE_DROP: 61,\n\t\t\tTABLE_LIST: 62,\n\t\t\tCONFIG: 174,\n\t\t\tSTATUS: 175,\n\t\t\tWAIT: 177,\n\t\t\tRECONFIGURE: 176,\n\t\t\tREBALANCE: 179,\n\t\t\tSYNC: 138,\n\t\t\tGRANT: 188,\n\t\t\tINDEX_CREATE: 75,\n\t\t\tINDEX_DROP: 76,\n\t\t\tINDEX_LIST: 77,\n\t\t\tINDEX_STATUS: 139,\n\t\t\tINDEX_WAIT: 140,\n\t\t\tINDEX_RENAME: 156,\n\t\t\tFUNCALL: 64,\n\t\t\tBRANCH: 65,\n\t\t\tOR: 66,\n\t\t\tAND: 67,\n\t\t\tFOR_EACH: 68,\n\t\t\tFUNC: 69,\n\t\t\tASC: 73,\n\t\t\tDESC: 74,\n\t\t\tINFO: 79,\n\t\t\tMATCH: 97,\n\t\t\tUPCASE: 141,\n\t\t\tDOWNCASE: 142,\n\t\t\tSAMPLE: 81,\n\t\t\tDEFAULT: 92,\n\t\t\tJSON: 98,\n\t\t\tTO_JSON_STRING: 172,\n\t\t\tISO8601: 99,\n\t\t\tTO_ISO8601: 100,\n\t\t\tEPOCH_TIME: 101,\n\t\t\tTO_EPOCH_TIME: 102,\n\t\t\tNOW: 103,\n\t\t\tIN_TIMEZONE: 104,\n\t\t\tDURING: 105,\n\t\t\tDATE: 106,\n\t\t\tTIME_OF_DAY: 126,\n\t\t\tTIMEZONE: 127,\n\t\t\tYEAR: 128,\n\t\t\tMONTH: 129,\n\t\t\tDAY: 130,\n\t\t\tDAY_OF_WEEK: 131,\n\t\t\tDAY_OF_YEAR: 132,\n\t\t\tHOURS: 133,\n\t\t\tMINUTES: 134,\n\t\t\tSECONDS: 135,\n\t\t\tTIME: 136,\n\t\t\tMONDAY: 107,\n\t\t\tTUESDAY: 108,\n\t\t\tWEDNESDAY: 109,\n\t\t\tTHURSDAY: 110,\n\t\t\tFRIDAY: 111,\n\t\t\tSATURDAY: 112,\n\t\t\tSUNDAY: 113,\n\t\t\tJANUARY: 114,\n\t\t\tFEBRUARY: 115,\n\t\t\tMARCH: 116,\n\t\t\tAPRIL: 117,\n\t\t\tMAY: 118,\n\t\t\tJUNE: 119,\n\t\t\tJULY: 120,\n\t\t\tAUGUST: 121,\n\t\t\tSEPTEMBER: 122,\n\t\t\tOCTOBER: 123,\n\t\t\tNOVEMBER: 124,\n\t\t\tDECEMBER: 125,\n\t\t\tLITERAL: 137,\n\t\t\tGROUP: 144,\n\t\t\tSUM: 145,\n\t\t\tAVG: 146,\n\t\t\tMIN: 147,\n\t\t\tMAX: 148,\n\t\t\tSPLIT: 149,\n\t\t\tUNGROUP: 150,\n\t\t\tRANDOM: 151,\n\t\t\tCHANGES: 152,\n\t\t\tARGS: 154,\n\t\t\tBINARY: 155,\n\t\t\tGEOJSON: 157,\n\t\t\tTO_GEOJSON: 158,\n\t\t\tPOINT: 159,\n\t\t\tLINE: 160,\n\t\t\tPOLYGON: 161,\n\t\t\tDISTANCE: 162,\n\t\t\tINTERSECTS: 163,\n\t\t\tINCLUDES: 164,\n\t\t\tCIRCLE: 165,\n\t\t\tGET_INTERSECTING: 166,\n\t\t\tFILL: 167,\n\t\t\tGET_NEAREST: 168,\n\t\t\tPOLYGON_SUB: 171,\n\t\t\tMINVAL: 180,\n\t\t\tMAXVAL: 181\n\t\t},\n\t\t\n\t\tAssocPair: {}\n\t}\n}\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/connection.js":"var net = require('net');\nvar tls = require('tls');\nvar Promise = require('bluebird');\nvar events = require('events');\nvar util = require('util');\nvar crypto = require('crypto');\n\nvar helper = require(__dirname+'/helper.js');\nvar Err = require(__dirname+'/error.js');\nvar Cursor = require(__dirname+'/cursor.js');\nvar ReadableStream = require(__dirname+'/stream.js');\nvar Metadata = require(__dirname+'/metadata.js');\n\nvar protodef = require(__dirname+'/protodef.js');\nvar responseTypes = protodef.Response.ResponseType;\n\n// We'll ping a connection using this special value.\nvar PING_VALUE = \"__rethinkdbdash_ping__\";\n\nvar PROTOCOL_VERSION = 0;\nvar AUTHENTIFICATION_METHOD = \"SCRAM-SHA-256\";\nvar KEY_LENGTH = 32; // Because we are currently using SHA 256\nvar NULL_BUFFER = new Buffer('\\0', \"binary\");\nvar CACHE_PBKDF2 = {};\n\nfunction Connection(r, options, resolve, reject) {\n  var self = this;\n  this.r = r;\n  this.state = 0; // Track the progress of the handshake. -1 will be used for an error state.\n\n  // Set default options - We have to save them in case the user tries to reconnect\n  if (!helper.isPlainObject(options)) options = {};\n  this.host = options.host || r._host;\n  this.port = options.port || r._port;\n  if (options.authKey != null) {\n    if (options.user != null || options.password != null) {\n      throw new Err.ReqlDriverError('Cannot use both authKey and password');\n    }\n    this.user = r._user;\n    this.password = options.authKey;\n  } else {\n    if (options.user === undefined) {\n      this.user = r._user;\n    } else {\n      this.user = options.user;\n    }\n    if (options.password === undefined) {\n      this.password = r._password;\n    } else {\n      this.password = options.password;\n    }\n  }\n\n  this.authKey = options.authKey || r._authKey;\n  // period in *seconds* for the connection to be opened\n  this.timeoutConnect = options.timeout || r._timeoutConnect;\n  // The connection will be pinged every <pingInterval> seconds\n  this.pingInterval = options.pingInterval || r._pingInterval;\n\n  if (options.db) this.db = options.db; // Pass to each query\n\n  this.token = 1;\n  this.buffer = new Buffer(0);\n\n  this.metadata = {}\n\n  this.open = false; // true only if the user can write on the socket\n  this.timeout = null;\n\n  if (options.connection) {\n    this.connection = options.connection;\n  }\n  else {\n    var family = 'IPv4';\n    if (net.isIPv6(self.host)) {\n      family = 'IPv6';\n    }\n\n    var connectionArgs = {\n      host: self.host,\n      port: self.port,\n      family: family\n    }\n\n    var tlsOptions = options.ssl || false;\n    if (tlsOptions === false) {\n      self.connection = net.connect(connectionArgs);\n    } else {\n      if (helper.isPlainObject(tlsOptions)) {\n        // Copy the TLS options in connectionArgs\n        helper.loopKeys(tlsOptions, function(tlsOptions, key) {\n          connectionArgs[key] = tlsOptions[key];\n        });\n      }\n      self.connection = tls.connect(connectionArgs);\n    }\n  }\n\n  self.connection.setKeepAlive(true);\n\n  self.timeoutOpen = setTimeout(function() {\n    self.connection.end(); // Send a FIN packet\n    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+' in less than '+self.timeoutConnect+'s').setOperational());\n  }, self.timeoutConnect*1000);\n\n  self.connection.on('end', function() {\n    self.open = false;\n    self.emit('end');\n    // We got a FIN packet, so we'll just flush\n    self._flush();\n  });\n  self.connection.on('close', function() {\n    // We emit end or close just once\n    clearTimeout(self.timeoutOpen)\n    clearInterval(self.pingIntervalId);\n    self.connection.removeAllListeners();\n    self.open = false;\n    self.emit('closed');\n    // The connection is fully closed, flush (in case 'end' was not triggered)\n    self._flush();\n  });\n  self.connection.setNoDelay();\n  self.connection.once('error', function(error) {\n    reject(new Err.ReqlDriverError('Failed to connect to '+self.host+':'+self.port+'\\nFull error:\\n'+JSON.stringify(error)).setOperational());\n  });\n  self.connection.on('connect', function() {\n    self.connection.removeAllListeners('error');\n    self.connection.on('error', function(error) {\n      self.emit('error', error);\n    });\n\n    var versionBuffer = new Buffer(4)\n    versionBuffer.writeUInt32LE(protodef.VersionDummy.Version.V1_0, 0)\n\n    self.randomString = new Buffer(crypto.randomBytes(18)).toString('base64')\n    var authBuffer = new Buffer(JSON.stringify({\n      protocol_version: PROTOCOL_VERSION,\n      authentication_method: AUTHENTIFICATION_METHOD,\n      authentication: \"n,,n=\" + self.user + \",r=\" + self.randomString\n    }));\n\n    helper.tryCatch(function() {\n      self.connection.write(Buffer.concat([versionBuffer, authBuffer, NULL_BUFFER]));\n    }, function(err) {\n      // The TCP connection is open, but the ReQL connection wasn't established.\n      // We can just abort the whole thing\n      self.open = false;\n      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n    });\n  });\n  self.connection.once('end', function() {\n    self.open = false;\n  });\n\n  self.connection.on('data', function(buffer) {\n    if (self.state === -1) {\n      // This is an error state\n      return;\n    }\n    self.buffer = Buffer.concat([self.buffer, buffer]);\n\n    if (self.open == false) {\n      for(var i=0; i<self.buffer.length; i++) {\n        if (self.buffer[i] === 0) {\n          var messageServerStr = self.buffer.slice(0, i).toString();\n          self.buffer = self.buffer.slice(i+1); // +1 to remove the null byte\n          try {\n            var messageServer = JSON.parse(messageServerStr);\n          } catch(error) {\n            self._abort();\n            reject(new Err.ReqlDriverError('Could not parse the message sent by the server : \\''+messageServerStr+'\\'').setOperational());\n            return;\n          }\n          if (messageServer.success !== true) {\n            self._abort();\n            reject(new Err.ReqlDriverError('Error '+messageServer.error_code+':'+messageServer.error).setOperational());\n            return;\n          }\n\n          if (self.state === 0) {\n            self._checkProtocolVersion(messageServer, reject);\n          } else if (self.state === 1) {\n            // Compute salt and send the proof\n            self._computeSaltedPassword(messageServer, reject);\n          } else if (self.state === 2) {\n            self._compareDigest(messageServer, resolve, reject);\n          }\n        }\n      }\n    }\n    else {\n      while(self.buffer.length >= 12) {\n        var token = self.buffer.readUInt32LE(0) + 0x100000000 * self.buffer.readUInt32LE(4);\n        var responseLength = self.buffer.readUInt32LE(8);\n\n        if (self.buffer.length < 12+responseLength) break;\n\n        var responseBuffer = self.buffer.slice(12, 12+responseLength);\n        var response = JSON.parse(responseBuffer);\n\n        self._processResponse(response, token);\n\n        self.buffer = self.buffer.slice(12+responseLength);\n      }\n    }\n  });\n\n  self.connection.on('timeout', function(buffer) {\n    self.connection.open = false;\n    self.emit('timeout');\n  })\n  self.connection.toJSON = function() { // We want people to be able to jsonify a cursor\n    return '\"A socket object cannot be converted to JSON due to circular references.\"'\n  }\n}\n\nutil.inherits(Connection, events.EventEmitter);\n\nConnection.prototype._checkProtocolVersion = function(messageServer, reject) {\n  // Expect max_protocol_version, min_protocol_version, server_version, success\n  var minVersion = messageServer.min_protocol_version\n  var maxVersion = messageServer.max_protocol_version\n\n  if (minVersion > PROTOCOL_VERSION || maxVersion < PROTOCOL_VERSION) {\n    this._abort();\n    reject(new Err.ReqlDriverError('Unsupported protocol version: '+PROTOCOL_VERSION+', expected between '+minVersion+' and '+ maxVersion).setOperational());\n  }\n  this.state = 1;\n};\n\nConnection.prototype._computeSaltedPassword = function(messageServer, reject) {\n  var self = this;\n  var authentication = helper.splitCommaEqual(messageServer.authentication);\n\n  var randomNonce = authentication.r\n  var salt = new Buffer(authentication.s, 'base64')\n  var iterations = parseInt(authentication.i)\n\n  if (randomNonce.substr(0, self.randomString.length) !== self.randomString) {\n    self._abort();\n    reject(new Err.ReqlDriverError('Invalid nonce from server').setOperational());\n  }\n\n  // The salt is constant, so we can cache the salted password.\n  var cacheKey = self.password.toString(\"base64\")+','+salt.toString(\"base64\")+','+iterations;\n  if (CACHE_PBKDF2.hasOwnProperty(cacheKey)) {\n    helper.tryCatch(function() {\n      self._sendProof(messageServer.authentication, randomNonce, CACHE_PBKDF2[cacheKey]);\n    }, function(err) {\n      // The TCP connection is open, but the ReQL connection wasn't established.\n      // We can just abort the whole thing\n      self.open = false;\n      reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n    });\n  } else {\n    crypto.pbkdf2(self.password, salt, iterations, KEY_LENGTH, \"sha256\", function(error, saltedPassword) {\n      if (error != null) {\n        self._abort();\n        reject(new Err.ReqlDriverError('Could not derive the key. Error:' + error.toString()).setOperational());\n      }\n      CACHE_PBKDF2[cacheKey] = saltedPassword;\n      helper.tryCatch(function() {\n        self._sendProof(messageServer.authentication, randomNonce, saltedPassword);\n      }, function(err) {\n        // The TCP connection is open, but the ReQL connection wasn't established.\n        // We can just abort the whole thing\n        self.open = false;\n        reject(new Err.ReqlDriverError('Failed to perform handshake with '+self.host+':'+self.port).setOperational());\n      });\n    })\n  }\n}\n\nConnection.prototype._sendProof = function(authentication, randomNonce, saltedPassword) {\n  var clientFinalMessageWithoutProof = \"c=biws,r=\" + randomNonce;\n  var clientKey = crypto.createHmac(\"sha256\", saltedPassword).update(\"Client Key\").digest()\n  var storedKey = crypto.createHash(\"sha256\").update(clientKey).digest()\n\n  var authMessage =\n      \"n=\" + this.user + \",r=\" + this.randomString + \",\" +\n      authentication + \",\" +\n      clientFinalMessageWithoutProof\n\n  var clientSignature = crypto.createHmac(\"sha256\", storedKey).update(authMessage).digest()\n  var clientProof = helper.xorBuffer(clientKey, clientSignature)\n\n  var serverKey = crypto.createHmac(\"sha256\", saltedPassword).update(\"Server Key\").digest()\n  this.serverSignature = crypto.createHmac(\"sha256\", serverKey).update(authMessage).digest()\n\n  this.state = 2\n  var message = JSON.stringify({\n    authentication: clientFinalMessageWithoutProof + \",p=\" + clientProof.toString(\"base64\")\n  })\n  this.connection.write(Buffer.concat([new Buffer(message.toString()), NULL_BUFFER]))\n}\n\nConnection.prototype._compareDigest = function(messageServer, resolve, reject) {\n  var self = this;\n  var firstEquals = messageServer.authentication.indexOf('=')\n  var serverSignatureValue = messageServer.authentication.slice(firstEquals+1)\n\n  if (!helper.compareDigest(serverSignatureValue, self.serverSignature.toString(\"base64\"))) {\n    reject(new Err.ReqlDriverError('Invalid server signature').setOperational());\n  }\n\n  self.state = 4\n  self.connection.removeAllListeners('error');\n  self.open = true;\n  self.connection.on('error', function(e) {\n    self.open = false;\n  });\n  clearTimeout(self.timeoutOpen)\n  resolve(self);\n  if (self.pingInterval > 0) {\n    self.pingIntervalId = setInterval(function() {\n      self.pendingPing = true;\n      self.r.error(PING_VALUE).run(self).error(function(error) {\n        self.pendingPing = false;\n        if (error.message !== PING_VALUE) {\n          self.emit('error', new Err.ReqlDriverError(\n                'Could not ping the connection').setOperational());\n          self.open = false;\n          self.connection.end();\n        } else {\n        }\n      });\n    }, self.pingInterval*1000);\n  }\n}\n\nConnection.prototype._abort = function() {\n  this.state = -1;\n  this.removeAllListeners();\n  this.close();\n}\n\nConnection.prototype._processResponse = function(response, token) {\n  //console.log('Connection.prototype._processResponse: '+token);\n  //console.log(JSON.stringify(response, null, 2));\n  var self = this;\n\n  var type = response.t;\n  var result;\n  var cursor;\n  var stream;\n  var currentResolve, currentReject;\n  var datum;\n  var options;\n\n  if (type === responseTypes.COMPILE_ERROR) {\n    self.emit('release');\n    if (typeof self.metadata[token].reject === 'function') {\n      self.metadata[token].reject(new Err.ReqlCompileError(helper.makeAtom(response), self.metadata[token].query, response));\n    }\n\n    delete self.metadata[token]\n  }\n  else if (type === responseTypes.CLIENT_ERROR) {\n    self.emit('release');\n\n    if (typeof self.metadata[token].reject === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));\n      if (typeof self.metadata[token].endReject !== 'function') {\n        // No pending STOP query, we can delete\n        delete self.metadata[token]\n      }\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n      currentReject(new Err.ReqlClientError(helper.makeAtom(response), self.metadata[token].query, response));\n      delete self.metadata[token]\n    }\n    else if (token === -1) { // This should not happen now since 1.13 took the token out of the query\n      var error = new Err.ReqlClientError(helper.makeAtom(response)+'\\nClosing all outstanding queries...');\n      self.emit('error', error);\n      // We don't want a function to yield forever, so we just reject everything\n      helper.loopKeys(self.rejectMap, function(rejectMap, key) {\n        rejectMap[key](error);\n      });\n      self.close();\n      delete self.metadata[token]\n    }\n  }\n  else if (type === responseTypes.RUNTIME_ERROR) {\n    var errorValue = helper.makeAtom(response);\n    var error;\n    // We don't want to release a connection if we just pinged it.\n    if (self.pendingPing === false || (errorValue !== PING_VALUE)) {\n      self.emit('release');\n      error = new Err.ReqlRuntimeError(errorValue, self.metadata[token].query, response);\n    } else {\n      error = new Err.ReqlRuntimeError(errorValue);\n    }\n\n    if (typeof self.metadata[token].reject === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n      error.setName(response.e);\n      currentReject(error);\n      if (typeof self.metadata[token].endReject !== 'function') {\n        // No pending STOP query, we can delete\n        delete self.metadata[token]\n      }\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n      delete self.metadata[token]\n    }\n  }\n  else if (type === responseTypes.SUCCESS_ATOM) {\n    self.emit('release');\n    // self.metadata[token].resolve is always a function\n    datum = helper.makeAtom(response, self.metadata[token].options);\n\n    if ((Array.isArray(datum)) &&\n        ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true)))) {\n      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');\n      if (self.metadata[token].options.profile === true) {\n        self.metadata[token].resolve({\n          profile: response.p,\n          result: cursor\n        });\n      }\n      else {\n        self.metadata[token].resolve(cursor);\n      }\n\n      cursor._push({done: true, response: { r: datum }});\n    }\n    else if ((Array.isArray(datum)) &&\n        ((self.metadata[token].options.stream === true || self.r._options.stream === true))) {\n      cursor = new Cursor(self, token, self.metadata[token].options, 'cursor');\n      stream = new ReadableStream({}, cursor);\n      if (self.metadata[token].options.profile === true) {\n        self.metadata[token].resolve({\n          profile: response.p,\n          result: stream \n        });\n      }\n      else {\n        self.metadata[token].resolve(stream);\n      }\n      cursor._push({done: true, response: { r: datum }});\n    }\n    else {\n      if (self.metadata[token].options.profile === true) {\n        result = {\n          profile: response.p,\n          result: cursor || datum\n        }\n      }\n      else {\n        result = datum;\n      }\n      self.metadata[token].resolve(result);\n    }\n\n    delete self.metadata[token];\n  }\n  else if (type === responseTypes.SUCCESS_PARTIAL) {\n    // We save the current resolve function because we are going to call cursor._fetch before resuming the user's yield\n    var done = false;\n    if (typeof self.metadata[token].resolve !== 'function') {\n      // According to issues/190, we can get a SUCESS_COMPLETE followed by a\n      // SUCCESS_PARTIAL when closing an feed. So resolve/reject will be undefined\n      // in this case.\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      if (typeof currentResolve === 'function') {\n        done = true;\n      }\n    }\n    else {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n    }\n\n    // We need to delete before calling cursor._push\n    self.metadata[token].removeCallbacks();\n\n    if (!self.metadata[token].cursor) { //No cursor, let's create one\n      self.metadata[token].cursor = true;\n\n      var typeResult = 'Cursor';\n      var includesStates = false;;\n      if (Array.isArray(response.n)) {\n        for(var i=0; i<response.n.length; i++) {\n          if (response.n[i] === protodef.Response.ResponseNote.SEQUENCE_FEED) {\n            typeResult = 'Feed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.ATOM_FEED) {\n            typeResult = 'AtomFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.ORDER_BY_LIMIT_FEED) {\n            typeResult = 'OrderByLimitFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.UNIONED_FEED) {\n            typeResult = 'UnionedFeed';\n          }\n          else if (response.n[i] === protodef.Response.ResponseNote.INCLUDES_STATES) {\n            includesStates = true;\n          }\n          else {\n            currentReject(new Err.ReqlDriverError('Unknown ResponseNote '+response.n[i]+', the driver is probably out of date.').setOperational());\n            return;\n          }\n        }\n      }\n      cursor = new Cursor(self, token, self.metadata[token].options, typeResult);\n      if (includesStates === true) {\n        cursor.setIncludesStates();\n      }\n      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {\n        // Return a cursor\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n      }\n      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {\n        stream = new ReadableStream({}, cursor);\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: stream \n          });\n        }\n        else {\n          currentResolve(stream);\n        }\n      }\n      else if (typeResult !== 'Cursor') {\n        // Return a feed\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n      }\n      else {\n        // When we get SUCCESS_SEQUENCE, we will delete self.metadata[token].options\n        // So we keep a reference of it here\n        options = self.metadata[token].options;\n\n        // Fetch everything and return an array\n        cursor.toArray().then(function(result) {\n          if (options.profile === true) {\n            currentResolve({\n              profile: response.p,\n              result: result\n            });\n          }\n          else {\n            currentResolve(result);\n          }\n        }).error(currentReject)\n      }\n      cursor._push({done: false, response: response});\n    }\n    else { // That was a continue query\n      currentResolve({done: done, response: response});\n    }\n  }\n  else if (type === responseTypes.SUCCESS_SEQUENCE) {\n    self.emit('release');\n\n    if (typeof self.metadata[token].resolve === 'function') {\n      currentResolve = self.metadata[token].resolve;\n      currentReject = self.metadata[token].reject;\n      self.metadata[token].removeCallbacks();\n    }\n    else if (typeof self.metadata[token].endResolve === 'function') {\n      currentResolve = self.metadata[token].endResolve;\n      currentReject = self.metadata[token].endReject;\n      self.metadata[token].removeEndCallbacks();\n    }\n\n    if (!self.metadata[token].cursor) { // No cursor, let's create one\n      cursor = new Cursor(self, token, self.metadata[token].options, 'Cursor');\n\n      if ((self.metadata[token].options.cursor === true) || ((self.metadata[token].options.cursor === undefined) && (self.r._options.cursor === true))) {\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: cursor\n          });\n        }\n        else {\n          currentResolve(cursor);\n        }\n\n        // We need to keep the options in the else statement, so we clean it inside the if/else blocks\n        if (typeof self.metadata[token].endResolve !== 'function') {\n          delete self.metadata[token];\n        }\n      }\n      else if ((self.metadata[token].options.stream === true || self.r._options.stream === true)) {\n        stream = new ReadableStream({}, cursor);\n        if (self.metadata[token].options.profile === true) {\n          currentResolve({\n            profile: response.p,\n            result: stream\n          });\n        }\n        else {\n          currentResolve(stream);\n        }\n\n        // We need to keep the options in the else statement,\n        // so we clean it inside the if/else blocks (the one looking \n        // if a cursor was already created)\n        if (typeof self.metadata[token].endResolve !== 'function') {\n          // We do not want to delete the metadata if there is an END query waiting\n          delete self.metadata[token];\n        }\n\n      }\n      else {\n        cursor.toArray().then(function(result) {\n          if (self.metadata[token].options.profile === true) {\n            currentResolve({\n              profile: response.p,\n              result: result\n            });\n          }\n          else {\n            currentResolve(result);\n          }\n          if (typeof self.metadata[token].endResolve !== 'function') {\n            delete self.metadata[token];\n          }\n\n        }).error(currentReject)\n      }\n      done = true;\n      cursor._push({done: true, response: response});\n    }\n    else { // That was a continue query\n      // If there is a pending STOP query we do not want to close the cursor yet\n      done = true;\n      if (typeof self.metadata[token].endResolve === 'function') {\n        done = false;\n      }\n      currentResolve({done: done, response: response});\n    }\n  }\n  else if (type === responseTypes.WAIT_COMPLETE) {\n    self.emit('release');\n    self.metadata[token].resolve();\n\n    delete self.metadata[token];\n  }\n  else if (type === responseTypes.SERVER_INFO) {\n    self.emit('release');\n    datum = helper.makeAtom(response, self.metadata[token].options);\n    self.metadata[token].resolve(datum);\n    delete self.metadata[token];\n  }\n}\n\nConnection.prototype.reconnect = function(options, callback) {\n  var self = this;\n\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n\n  if (!helper.isPlainObject(options)) options = {};\n\n  if (options.noreplyWait === true) {\n    var p = new Promise(function(resolve, reject) {\n      self.close(options).then(function() {\n        self.r.connect({\n          host: self.host,\n          port: self.port,\n          authKey: self.authKey,\n          db: self.db\n        }).then(function(c) {\n          resolve(c);\n        }).error(function(e) {\n          reject(e);\n        });\n      }).error(function(e) {\n        reject(e)\n      })\n    }).nodeify(callback);\n  }\n  else {\n    return self.r.connect({\n      host: self.host,\n      port: self.port,\n      authKey: self.authKey,\n      db: self.db\n    }, callback);\n  }\n\n  return p;\n}\n\nConnection.prototype._send = function(query, token, resolve, reject, originalQuery, options, end) {\n  //console.log('Connection.prototype._send: '+token);\n  //console.log(JSON.stringify(query, null, 2));\n\n  var self = this;\n  if (self.open === false) {\n    var err = new Err.ReqlDriverError('The connection was closed by the other party');\n    err.setOperational();\n    reject(err);\n    return;\n  }\n\n  var queryStr = JSON.stringify(query);\n  var querySize = Buffer.byteLength(queryStr);\n\n  var buffer = new Buffer(8+4+querySize);\n  buffer.writeUInt32LE(token & 0xFFFFFFFF, 0)\n  buffer.writeUInt32LE(Math.floor(token / 0xFFFFFFFF), 4)\n\n  buffer.writeUInt32LE(querySize, 8);\n\n  buffer.write(queryStr, 12);\n\n  // noreply instead of noReply because the otpions are translated for the server\n  if ((!helper.isPlainObject(options)) || (options.noreply != true)) {\n    if (!self.metadata[token]) {\n      self.metadata[token] = new Metadata(resolve, reject, originalQuery, options);\n    }\n    else if (end === true) {\n      self.metadata[token].setEnd(resolve, reject);\n    }\n    else {\n      self.metadata[token].setCallbacks(resolve, reject);\n    }\n  }\n  else {\n    if (typeof resolve === 'function') resolve();\n    this.emit('release');\n  }\n\n  // This will emit an error if the connection is closed\n  helper.tryCatch(function() {\n    self.connection.write(buffer);\n  }, function(err) {\n    self.metadata[token].reject(err);\n    delete self.metadata[token]\n  });\n\n};\n\nConnection.prototype._continue = function(token, resolve, reject) {\n  var query = [protodef.Query.QueryType.CONTINUE];\n  this._send(query, token, resolve, reject);\n}\nConnection.prototype._end = function(token, resolve, reject) {\n  var query = [protodef.Query.QueryType.STOP];\n  this._send(query, token, resolve, reject, undefined, undefined, true);\n}\n\n\nConnection.prototype.use = function(db) {\n  if (typeof db !== 'string') throw new Err.ReqlDriverError('First argument of `use` must be a string')\n  this.db = db;\n}\n\nConnection.prototype.server = function(callback) {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    var query = [protodef.Query.QueryType.SERVER_INFO];\n    self._send(query, self._getToken(), resolve, reject, undefined, undefined, true);\n  }).nodeify(callback);\n}\n\n// Return the next token and update it.\nConnection.prototype._getToken = function() {\n  return this.token++;\n}\n\nConnection.prototype.close = function(options, callback) {\n  if (typeof options === 'function') {\n    callback = options;\n    options = {};\n  }\n  var self = this;\n\n  var p = new Promise(function(resolve, reject) {\n    if (!helper.isPlainObject(options)) options = {};\n    if (options.noreplyWait === true) {\n      self.noreplyWait().then(function(r) {\n        self.open = false;\n        self.connection.end()\n        resolve(r);\n      }).error(function(e) {\n        reject(e)\n      });\n    }\n    else{\n      self.open = false;\n      self.connection.end();\n      resolve();\n    }\n  }).nodeify(callback);\n  return p;\n};\n\n\nConnection.prototype.noReplyWait = function() {\n  throw new Err.ReqlDriverError('Did you mean to use `noreplyWait` instead of `noReplyWait`?')\n}\nConnection.prototype.noreplyWait = function(callback) {\n  var self = this;\n  var token = self._getToken();\n\n  var p = new Promise(function(resolve, reject) {\n    var query = [protodef.Query.QueryType.NOREPLY_WAIT];\n\n    self._send(query, token, resolve, reject);\n  }).nodeify(callback);\n  return p;\n}\nConnection.prototype._isConnection = function() {\n  return true;\n}\nConnection.prototype._isOpen = function() {\n  return this.open;\n}\n\nConnection.prototype._flush = function() {\n  helper.loopKeys(this.metadata, function(metadata, key) {\n    if (typeof metadata[key].reject === 'function') {\n      metadata[key].reject(new Err.ReqlServerError(\n            'The connection was closed before the query could be completed.',\n            metadata[key].query));\n    }\n    if (typeof metadata[key].endReject === 'function') {\n      metadata[key].endReject(new Err.ReqlServerError(\n            'The connection was closed before the query could be completed.',\n            metadata[key].query));\n    }\n  });\n  this.metadata = {};\n}\n\nmodule.exports = Connection\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/error.js":"var helper = require(__dirname+'/helper.js');\nvar INDENT = 4;\nvar LIMIT = 80;\nvar IS_OPERATIONAL = 'isOperational';\n\nvar protodef = require(__dirname+'/protodef.js');\nvar responseTypes = protodef.Response.ResponseType;\nvar protoErrorType = protodef.Response.ErrorType;\nvar termTypes = protodef.Term.TermType;\nvar datumTypes = protodef.Datum.DatumType;\nvar frameTypes = protodef.Frame.FrameType;\n\n\nfunction ReqlDriverError(message, query, secondMessage) {\n  Error.captureStackTrace(this, ReqlDriverError);\n  this.message = this.msg = message;\n\n  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' after:\\n';\n\n    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});\n\n    this.message += backtrace.str;\n  }\n  else {\n    if (this.message[this.message.length-1] !== '?') this.message += '.';\n  }\n  if (secondMessage) this.message += '\\n'+secondMessage;\n};\nReqlDriverError.prototype = new Error();\nReqlDriverError.prototype.name = 'ReqlDriverError';\nReqlDriverError.prototype.setOperational = function() {\n  this[IS_OPERATIONAL] = true;\n  return this;\n};\n\nmodule.exports.ReqlDriverError = ReqlDriverError;\n\n\nfunction ReqlServerError(message, query) {\n  Error.captureStackTrace(this, ReqlServerError);\n  this.message = this.msg = message;\n\n  if ((Array.isArray(query) && (query.length > 0)) || (!Array.isArray(query) && query != null)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' for:\\n';\n\n    var backtrace = generateBacktrace(query, 0, null, [], {indent: 0, extra: 0});\n\n    this.message += backtrace.str;\n  }\n  else {\n    if (this.message[this.message.length-1] !== '?') this.message += '.';\n  }\n};\nReqlServerError.prototype = new Error();\nReqlServerError.prototype.name = 'ReqlServerError';\nReqlServerError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlServerError = ReqlServerError;\n\n\nfunction ReqlRuntimeError(message, query, frames) {\n  Error.captureStackTrace(this, ReqlRuntimeError);\n  this.message = this.msg = message;\n\n  if ((query != null) && (frames)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n    \n    this.message += ' in:\\n';\n\n    frames = frames.b;\n    if (frames) this.frames = frames.slice(0);\n    //this.frames = JSON.stringify(frames, null, 2);\n\n    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});\n\n    var queryLines = backtrace.str.split('\\n');\n    var carrotLines = backtrace.car.split('\\n');\n\n    for(var i=0; i<queryLines.length; i++) {\n      this.message += queryLines[i]+'\\n';\n      if (carrotLines[i].match(/\\^/)) {\n        var pos = queryLines[i].match(/[^\\s]/);\n        if ((pos) && (pos.index)) {\n          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\\n';\n        }\n        else {\n          this.message += carrotLines[i]+'\\n';\n        }\n      }\n    }\n  }\n  //this.query = JSON.stringify(query, null, 2);\n};\nReqlRuntimeError.prototype = new Error();\nReqlRuntimeError.prototype.name = 'ReqlRuntimeError';\nReqlRuntimeError.prototype.setName = function(type) {\n  switch(type) {\n    case protoErrorType.INTERNAL:\n      this.name = 'ReqlInternalError';\n      break;\n    case protoErrorType.RESOURCE_LIMIT:\n      this.name = 'ReqlResourceError';\n      break;\n    case protoErrorType.QUERY_LOGIC:\n      this.name = 'ReqlLogicError';\n      break;\n    case protoErrorType.OP_FAILED:\n      this.name = 'ReqlOpFailedError';\n      break;\n    case protoErrorType.OP_INDETERMINATE:\n      this.name = 'ReqlOpIndeterminateError';\n      break;\n    case protoErrorType.USER:\n      this.name = 'ReqlUserError';\n      break;\n    //default: // Do nothing\n  }\n}\nReqlRuntimeError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlRuntimeError = ReqlRuntimeError;\n\n\nfunction ReqlCompileError(message, query, frames) {\n  Error.captureStackTrace(this, ReqlCompileError);\n  this.message = message;\n\n  if ((query != null) && (frames)) {\n    if ((this.message.length > 0) && (this.message[this.message.length-1] === '.')) {\n      this.message = this.message.slice(0, this.message.length-1);\n    }\n\n    this.message += ' in:\\n';\n\n    frames = frames.b;\n    if (frames) this.frames = frames.slice(0);\n    //this.frames = JSON.stringify(frames, null, 2);\n\n    var backtrace = generateBacktrace(query, 0, null, frames, {indent: 0, extra: 0});\n\n    var queryLines = backtrace.str.split('\\n');\n    var carrotLines = backtrace.car.split('\\n');\n\n    for(var i=0; i<queryLines.length; i++) {\n      this.message += queryLines[i]+'\\n';\n      if (carrotLines[i].match(/\\^/)) {\n        var pos = queryLines[i].match(/[^\\s]/);\n        if ((pos) && (pos.index)) {\n          this.message += space(pos.index)+carrotLines[i].slice(pos.index)+'\\n';\n        }\n        else {\n          this.message += carrotLines[i]+'\\n';\n        }\n      }\n    }\n  }\n};\nReqlCompileError.prototype = new Error();\nReqlCompileError.prototype.name = 'ReqlCompileError';\nReqlCompileError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlCompileError = ReqlCompileError;\n\n\nfunction ReqlClientError(message) {\n  Error.captureStackTrace(this, ReqlClientError);\n  this.message = message;\n};\nReqlClientError.prototype = new Error();\nReqlClientError.prototype.name = 'ReqlClientError';\nReqlClientError.prototype[IS_OPERATIONAL] = true;\n\nmodule.exports.ReqlClientError = ReqlClientError;\n\n\n\nvar _constants = {\n  MONDAY: true,\n  TUESDAY: true,\n  WEDNESDAY: true,\n  THURSDAY: true,\n  FRIDAY: true,\n  SATURDAY: true,\n  SUNDAY: true,\n  JANUARY: true,\n  FEBRUARY: true,\n  MARCH: true,\n  APRIL: true,\n  MAY: true,\n  JUNE: true,\n  JULY: true,\n  AUGUST: true,\n  SEPTEMBER: true,\n  OCTOBER: true,\n  NOVEMBER: true,\n  DECEMBER: true,\n  MINVAL: true,\n  MAXVAL: true,\n}\nvar constants = {};\nfor(var key in _constants) {\n  constants[termTypes[key]] = true;\n}\n\n\nvar _nonPrefix = {\n  DB: true,\n  DB_CREATE: true,\n  DB_LIST: true,\n  DB_DROP: true,\n  JS: true,\n  NOW: true,\n  TIME: true,\n  EPOCH_TIME: true,\n  ISO8601: true,\n  BRANCH: true,\n  JAVASCRIPT: true,\n  ERROR: true,\n  MAKE_ARRAY: true,\n  JSON: true,\n  ARGS: true,\n  HTTP: true,\n  RANDOM: true,\n  BINARY: true,\n  OBJECT: true,\n  CIRCLE: true,\n  GEOJSON: true,\n  POINT: true,\n  LINE: true,\n  POLYGON: true,\n  UUID: true,\n  DESC: true,\n  ASC: true,\n  RANGE: true,\n  LITERAL: 'true'\n}\nvar nonPrefix = {};\nfor(var key in _nonPrefix) {\n  nonPrefix[termTypes[key]] = true;\n}\n// Constants are also in nonPrefix\nfor(var key in _constants) {\n  nonPrefix[termTypes[key]] = true;\n}\n\n\nvar _typeToString = {\n  DB: 'db',\n  DB_CREATE: 'dbCreate',\n  DB_LIST: 'dbList',\n  DB_DROP: 'dbDrop',\n  TABLE_CREATE: 'tableCreate',\n  TABLE_LIST: 'tableList',\n  TABLE_DROP: 'tableDrop',\n  TABLE: 'table',\n  INDEX_CREATE: 'indexCreate',\n  INDEX_DROP: 'indexDrop',\n  INDEX_LIST: 'indexList',\n  INDEX_WAIT: 'indexWait',\n  INDEX_STATUS: 'indexStatus',\n  INSERT: 'insert',\n  UPDATE: 'update',\n  REPLACE: 'replace',\n  DELETE: 'delete',\n  SYNC: 'sync',\n  GET: 'get',\n  GET_ALL: 'getAll',\n  BETWEEN: 'between',\n  FILTER: 'filter',\n  INNER_JOIN: 'innerJoin',\n  OUTER_JOIN: 'outerJoin',\n  EQ_JOIN: 'eqJoin',\n  ZIP: 'zip',\n  MAP: 'map',\n  WITH_FIELDS: 'withFields',\n  CONCAT_MAP: 'concatMap',\n  ORDER_BY: 'orderBy',\n  DESC: 'desc',\n  ASC: 'asc',\n  SKIP: 'skip',\n  LIMIT: 'limit',\n  SLICE: 'slice',\n  NTH: 'nth',\n  OFFSETS_OF: 'offsetsOf',\n  IS_EMPTY: 'isEmpty',\n  UNION: 'union',\n  SAMPLE: 'sample',\n  REDUCE: 'reduce',\n  COUNT: 'count',\n  SUM: 'sum',\n  AVG: 'avg',\n  MIN: 'min',\n  MAX: 'max',\n  FOLD: 'fold',\n  OBJECT: 'object',\n  DISTINCT: 'distinct',\n  GROUP: 'group',\n  UNGROUP: 'ungroup',\n  CONTAINS: 'contains',\n  IMPLICIT_VAR: 'row',\n  PLUCK: 'pluck',\n  WITHOUT: 'without',\n  MERGE: 'merge',\n  APPEND: 'append',\n  PREPEND: 'prepend',\n  DIFFERENCE: 'difference',\n  SET_INSERT: 'setInsert',\n  SET_UNION: 'setUnion',\n  SET_INTERSECTION: 'setIntersection',\n  SET_DIFFERENCE: 'setDifference',\n  HAS_FIELDS: 'hasFields',\n  INSERT_AT: 'insertAt',\n  SPLICE_AT: 'spliceAt',\n  DELETE_AT: 'deleteAt',\n  CHANGE_AT: 'changeAt',\n  KEYS: 'keys',\n  VALUES: 'values',\n  MATCH: 'match',\n  UPCASE: 'upcase',\n  DOWNCASE: 'downcase',\n  ADD: 'add',\n  SUB: 'sub',\n  MUL: 'mul',\n  DIV: 'div',\n  MOD: 'mod',\n  AND: 'and',\n  OR: 'or',\n  EQ: 'eq',\n  NE: 'ne',\n  GT: 'gt',\n  GE: 'ge',\n  LT: 'lt',\n  LE: 'le',\n  NOT: 'not',\n  FLOOR: 'floor',\n  CEIL: 'ceil',\n  ROUND: 'round',\n  NOW: 'now',\n  TIME: 'time',\n  EPOCH_TIME: 'epochTime',\n  ISO8601: 'ISO8601',\n  IN_TIMEZONE: 'inTimezone',\n  TIMEZONE: 'timezone',\n  DURING: 'during',\n  DATE: 'date',\n  TIME_OF_DAY: 'timeOfDay',\n  YEAR: 'year',\n  MONTH: 'month',\n  DAY: 'day',\n  DAY_OF_WEEK: 'dayOfWeek',\n  DAY_OF_YEAR: 'dayOfYear',\n  HOURS: 'hours',\n  MINUTES: 'minutes',\n  SECONDS: 'seconds',\n  TO_ISO8601: 'toISO8601',\n  TO_EPOCH_TIME: 'toEpochTime',\n  FUNCALL: 'do',\n  BRANCH: 'branch',\n  FOR_EACH: 'forEach',\n  ERROR: 'error',\n  DEFAULT: 'default',\n  JAVASCRIPT: 'js',\n  COERCE_TO: 'coerceTo',\n  TYPE_OF: 'typeOf',\n  INFO: 'info',\n  JSON: 'json',\n  ARGS: 'args',\n  HTTP: 'http',\n  RANDOM: 'random',\n  CHANGES: 'changes',\n  BINARY: 'binary',\n  INDEX_RENAME: 'indexRename',\n  CIRCLE: 'circle',\n  DISTANCE: 'distance',\n  FILL: 'fill',\n  GEOJSON: 'geojson',\n  TO_GEOJSON: 'toGeojson',\n  GET_INTERSECTING: 'getIntersecting',\n  GET_NEAREST: 'getNearest',\n  INCLUDES: 'includes',\n  INTERSECTS: 'intersects',\n  LINE: 'line',\n  POINT: 'point',\n  POLYGON: 'polygon',\n  POLYGON_SUB: 'polygonSub',\n  UUID: 'uuid',\n  RANGE: 'range',\n  TO_JSON_STRING: 'toJSON',\n  CONFIG: 'config',\n  STATUS: 'status',\n  WAIT: 'wait',\n  RECONFIGURE: 'reconfigure',\n  REBALANCE: 'rebalance',\n  GRANT: 'grant',\n  SPLIT: 'split',\n  LITERAL: 'literal',\n  MONDAY: 'monday',\n  TUESDAY: 'tuesday',\n  WEDNESDAY: 'wednesday',\n  THURSDAY: 'thursday',\n  FRIDAY: 'friday',\n  SATURDAY: 'saturday',\n  SUNDAY: 'sunday',\n  JANUARY: 'january',\n  FEBRUARY: 'february',\n  MARCH: 'march',\n  APRIL: 'april',\n  MAY: 'may',\n  JUNE: 'june',\n  JULY: 'july',\n  AUGUST: 'august',\n  SEPTEMBER: 'september',\n  OCTOBER: 'october',\n  NOVEMBER: 'november',\n  DECEMBER: 'december' ,\n  MINVAL: 'minval',\n  MAXVAL: 'maxval',\n}\nvar typeToString = {};\nfor(var key in _typeToString) {\n  typeToString[termTypes[key]] = _typeToString[key];\n}\n\nvar _noPrefixOptargs = {\n  ISO8601: true,\n}\nvar noPrefixOptargs = {};\nfor(var key in _noPrefixOptargs) {\n  noPrefixOptargs[termTypes[key]] = true;\n}\n\nvar _specialType = {\n  DATUM: function(term, index, father, frames, options, optarg) {\n    optarg = optarg || false;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    var currentFrame, backtrace;\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    var result = {\n      str: '',\n      car: ''\n    }\n\n    if ((helper.isPlainObject(term)) && (term.$reql_type$ === 'BINARY')) {\n      carify(result, 'r.binary(<Buffer>)', underline);\n      return result;\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)\n\n    if (typeof term === 'string' ) {\n      carify(result, '\"'+term+'\"', underline);\n    }\n    else if (helper.isPlainObject(term)) {\n      var totalKeys = Object.keys(term).length;\n      if (totalKeys === 0) {\n        carify(result, '{}', underline);\n      }\n      else {\n        carify(result, '{\\n', underline);\n        var countKeys = 0;\n        var extraToRemove = options.extra;\n        options.indent += INDENT+options.extra;\n        options.extra = 0;\n        for(var key in term) {\n          countKeys++;\n          //if (!((father) && (Array.isArray(father[2])) && (Object.keys(father[2]).length > 0))) options.extra = 0;\n\n          if (optarg) {\n            carify(result, space(options.indent)+camelCase(key)+': ', underline);\n          }\n          else {\n            carify(result, space(options.indent)+key+': ', underline);\n          }\n          if ((currentFrame != null) && (currentFrame === key)) {\n            backtrace = generateBacktrace(term[key], i, term, frames, options);\n          }\n          else {\n            backtrace = generateBacktrace(term[key], i, term, null, options);\n          }\n          result.str += backtrace.str;\n          result.car += backtrace.car;\n          \n          if (countKeys !== totalKeys) { \n            carify(result, ',\\n', underline);\n          }\n\n        }\n        options.indent -= INDENT+extraToRemove;\n        carify(result, '\\n'+space(options.indent+extraToRemove)+'}', underline);\n      }\n    }\n    else if (Array.isArray(term)) {\n      carify(result, '[', underline);\n      for(var i=0; i<term.length; i++) {\n        if ((currentFrame != null) && (currentFrame === i)) {\n          backtrace = generateBacktrace(term[i], i, term, frames, options);\n        }\n        else {\n          backtrace = generateBacktrace(term[i], i, term, null, options);\n        }\n        result.str += backtrace.str;\n        result.car += backtrace.car;\n      }\n      carify(result, ']', underline);\n    }\n    else {\n      carify(result, ''+term, underline);\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  TABLE: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n\n    if ((term.length === 1) || (term[1].length === 0) || (term[1][0][0] !== termTypes.DB)) {\n      var underline = Array.isArray(frames) && (frames.length === 0);\n      if (Array.isArray(frames)) currentFrame = frames.shift();\n\n      carify(result, 'r.'+typeToString[term[0]]+'(', underline);\n      if (Array.isArray(term[1])) {\n        for(var i=0; i<term[1].length; i++) {\n          if (i !==0) result.str += ', ';\n\n\n          if ((currentFrame != null) && (currentFrame === 1)) {\n            // +1 for index because it's like if there was a r.db(...) before .table(...)\n            backtrace = generateBacktrace(term[1][i], i+1, term, frames, options)\n          }\n          else {\n            backtrace = generateBacktrace(term[1][i], i+1, term, null, options)\n          }\n          result.str += backtrace.str;\n          result.car += backtrace.car\n        }\n      }\n\n      backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n      carify(result, ')', underline);\n\n      if (underline) result.car = result.str.replace(/./g, '^');\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n\n    return result;\n  },\n  GET_FIELD: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options)\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options)\n    }\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n\n    carify(result, '(', underline);\n\n    if ((currentFrame != null) && (currentFrame === 1)) {\n      backtrace = generateBacktrace(term[1][1], 1, term, frames, options)\n    }\n    else {\n      backtrace = generateBacktrace(term[1][1], 1, term, null, options)\n    }\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  MAKE_ARRAY: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) carify(result, 'r.expr(', underline)\n\n    if (!((options) && (options.noBracket))) {\n      carify(result, '[', underline);\n    }\n    for(var i=0; i<term[1].length; i++) {\n      if (i !== 0) {\n        carify(result, ', ', underline);\n      }\n\n      if ((currentFrame != null) && (currentFrame  === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options);\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n    }\n\n    if (!((options) && (options.noBracket))) {\n      carify(result, ']', underline);\n    }\n\n    if ((index === 0) && ((father == null) || (!nonPrefix[father[0]]))) {\n      carify(result, ')', underline);\n    }\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  FUNC: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((term[1][0][1].length === 1) && (helper.hasImplicit(term[1][1]))) {\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 1, term, null, options);\n      }\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      carify(result, 'function(', underline);\n\n      for(var i=0; i<term[1][0][1].length; i++) {\n        if (i !== 0) {\n          carify(result, ', ', underline);\n        }\n        carify(result, 'var_'+term[1][0][1][i], underline);\n      }\n\n      options.indent += INDENT+options.extra;\n      var extraToRemove = options.extra;\n      options.extra = 0;\n      //if (!((Array.isArray(term[2])) && (term[2].length > 0))) options.extra = 0;\n\n      carify(result, ') {\\n'+space(options.indent)+'return ', underline);\n\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 1, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 1, term, null, options);\n      }\n\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n\n      options.indent -= INDENT+extraToRemove;\n      options.extra = extraToRemove;\n\n      carify(result, '\\n'+space(options.indent+extraToRemove)+'}', underline);\n\n    }\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  VAR: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    carify(result, 'var_'+term[1][0], underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n    return result;\n  },\n  FUNCALL: function(term, index, father, frames, options) {\n    // The syntax is args[1].do(args[0])\n    var result = {\n      str: '',\n      car: ''\n    };\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if (term[1].length === 2) {\n      if ((currentFrame != null) && (currentFrame === 1)) {\n        backtrace = generateBacktrace(term[1][1], 0, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][1], 0, term, null, options);\n      }\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n\n      carify(result, '.do(', underline);\n    }\n    else {\n      carify(result, 'r.do(', underline);\n\n      for(var i=1; i<term[1].length; i++) {\n        if ((currentFrame != null) && (currentFrame === i)) {\n          backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n        }\n        else {\n          backtrace = generateBacktrace(term[1][i], i, term, null, options);\n        }\n        result.str += backtrace.str;\n        result.car += backtrace.car;\n\n        if (i !== term[1].length) {\n          carify(result, ', ' , underline);\n        }\n      }\n    }\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options);\n    }\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    carify(result, ')', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n\n    return result;\n  },\n  IMPLICIT_VAR: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    carify(result, 'r.row', underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n    return result;\n  },\n  WAIT: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    if (term.length === 1 || term[1].length === 0) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    return result;\n  },\n  MAP: function(term, index, father, frames, options) {\n    var result = {\n      str: '',\n      car: ''\n    }\n    var backtrace, underline, currentFrame;\n\n    if (term.length > 1 && term[1].length > 2) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else {\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    return result;\n  },\n}\n_specialType.TABLE_CREATE = _specialType.TABLE;\n_specialType.TABLE_DROP = _specialType.TABLE;\n_specialType.TABLE_LIST = _specialType.TABLE;\n_specialType.RECONFIGURE = _specialType.WAIT;\n_specialType.REBALANCE = _specialType.WAIT;\n_specialType.BRACKET = _specialType.GET_FIELD;\n\nvar specialType = {};\nfor(var key in _specialType) {\n  specialType[termTypes[key]] = _specialType[key];\n}\n\n\nfunction space(n) {\n  return new Array(n+1).join(' ');\n}\nfunction carify(result, str, underline) {\n  if (underline === true) {\n    result.str += str;\n    result.car += str.replace(/[^\\n]/g, '^');\n  }\n  else {\n    result.str += str;\n    result.car += str.replace(/[^\\n]/g, ' ');\n  }\n}\nfunction makeOptargs(term, index, father, frames, options, currentFrame) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  if (helper.isPlainObject(term[2])) {\n    //if ((currentFrame != null) && (frames != null)) frames.unshift(currentFrame);\n\n    //underline = Array.isArray(frames) && (frames.length === 0);\n    var underline = false;\n    //if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    // This works before there is no prefix term than can be called with no normal argument but with an optarg\n    if (Array.isArray(term[1]) && (term[1].length > 1)) {\n      carify(result, ', ' , underline);\n    }\n    else if (Array.isArray(term[1]) && (term[1].length > 0) && (noPrefixOptargs[term[0]])) {\n      carify(result, ', ' , underline);\n    }\n\n    backtrace = specialType[termTypes.DATUM](term[2], index, term[2], frames, options, true);\n\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n  }\n\n  return result;\n}\nfunction generateNormalBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  //if (term[1]) {\n    var underline = Array.isArray(frames) && (frames.length === 0);\n    if (Array.isArray(frames)) currentFrame = frames.shift();\n\n    if ((currentFrame != null) && (currentFrame === 0)) {\n      backtrace = generateBacktrace(term[1][0], 0, term, frames, options);\n    }\n    else {\n      backtrace = generateBacktrace(term[1][0], 0, term, null, options);\n    }\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n\n    var lines = backtrace.str.split('\\n');\n    var line = lines[lines.length-1];\n    var pos = line.match(/[^\\s]/);\n    pos = (pos) ? pos.index : 0;\n\n    if (line.length-pos > LIMIT) {\n      if (options.extra === 0) options.extra += INDENT;\n      carify(result, '\\n'+space(options.indent+options.extra) , underline);\n    }\n\n    carify(result, '.'+typeToString[term[0]]+'(' , underline);\n    options.indent += options.extra;\n    var extraToRemove = options.extra;\n    options.extra = 0;\n\n    for(var i=1; i<term[1].length; i++) {\n      if (i !== 1) {\n        carify(result, ', ' , underline);\n      }\n      if ((currentFrame != null) && (currentFrame === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options);\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options);\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n    }\n\n    backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n    result.str += backtrace.str;\n    result.car += backtrace.car;\n\n    options.indent -= extraToRemove;\n    options.extra = extraToRemove;\n\n    carify(result, ')' , underline);\n\n    if (underline) result.car = result.str.replace(/./g, '^');\n  /*\n  }\n  else {\n    throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 1 --\\n'+JSON.stringify(term, null, 2))\n  }\n  */\n\n\n  return result;\n}\n\nfunction generateWithoutPrefixBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n\n  var backtrace, currentFrame, underline;\n\n  var underline = Array.isArray(frames) && (frames.length === 0);\n  if (Array.isArray(frames)) currentFrame = frames.shift();\n\n  if (constants[term[0]]) {\n    carify(result, 'r.'+typeToString[term[0]], underline); \n    return result;\n  }\n\n  carify(result, 'r.'+typeToString[term[0]]+'(', underline); \n\n  if (Array.isArray(term[1])) {\n    for(var i=0; i<term[1].length; i++) {\n      if (i !== 0) carify(result, ', ', underline)\n\n      if ((currentFrame != null) && (currentFrame === i)) {\n        backtrace = generateBacktrace(term[1][i], i, term, frames, options)\n      }\n      else {\n        backtrace = generateBacktrace(term[1][i], i, term, null, options)\n      }\n      result.str += backtrace.str;\n      result.car += backtrace.car;\n    }\n  }\n\n  backtrace = makeOptargs(term, i, term, frames, options, currentFrame)\n  result.str += backtrace.str;\n  result.car += backtrace.car;\n\n  carify(result, ')', underline);\n\n  if (underline) result.car = result.str.replace(/./g, '^');\n\n  return result;\n}\n\nfunction generateBacktrace(term, index, father, frames, options) {\n  var result = {\n    str: '',\n    car: ''\n  }\n  var backtrace, currentFrame, underline;\n\n  // frames = null -> do not underline\n  // frames = [] -> underline\n\n  if (Array.isArray(term)) {\n    if (term.length === 0) {\n      var underline = Array.isArray(frames) && (frames.length === 0);\n      carify(result, 'undefined', underline);\n    }\n    else if (specialType[term[0]]) {\n      backtrace = specialType[term[0]](term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else if (nonPrefix[term[0]]) {\n      backtrace = generateWithoutPrefixBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n    else { // normal type -- this.<method>( this.args... )\n      backtrace = generateNormalBacktrace(term, index, father, frames, options);\n      result.str = backtrace.str;\n      result.car = backtrace.car;\n    }\n  }\n  else if (term !== undefined) {\n    backtrace = specialType[termTypes.DATUM](term, index, father, frames, options);\n\n    result.str = backtrace.str;\n    result.car = backtrace.car;\n  }\n  else {\n    //throw new Error('The driver should never enter this condition. Please report the query to the developers -- End 2')\n  }\n  return result;\n}\n\nfunction camelCase(str) {\n  return str.replace(/_(.)/g, function (m, char) { return char.toUpperCase() });\n}\nmodule.exports.generateBacktrace = generateBacktrace;\n\nmodule.exports.setOperational = function(error) {\n  error[IS_OPERATIONAL] = true;\n  return error;\n};\n\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/cursor.js":"var Promise = require('bluebird');\nvar Err = require(__dirname+'/error.js');\nvar helper = require(__dirname+'/helper.js');\nvar EventEmitter = require('events').EventEmitter;\n\nvar MAX_CALL_STACK = 1000;\n\nfunction Cursor(connection, token, options, type) {\n  this.connection = connection;\n  this.token = token;\n\n  this._stackSize = 0; // Estimation of our call stack.\n  this._index = 0; // Position in this._data[0]\n  this._data = []; // Array of non empty arrays\n  this._fetching = false; // Are we fetching data\n  this._canFetch = true; // Can we fetch more data?\n  this._pendingPromises = []; // Pending promises' resolve/reject\n  this.options = options || {};\n  this._closed = false;\n  this._closingPromise = null; // Promise returned by close\n  this._type = type;\n  this._setIncludesStates = false;\n  if ((type === 'feed') || (type === 'atomFeed')) {\n    this.toArray = _unsupportedToArray;\n  }\n  this._emittedEnd = false;\n}\n\nCursor.prototype.toString = function() {\n  return '[object '+this._type+']';\n}\nCursor.prototype.setIncludesStates = function() {\n  this._setIncludesStates = true;\n}\nCursor.prototype.includesStates = function() {\n  return this._setIncludesStates;\n}\nCursor.prototype.getType = function() {\n  return this._type;\n}\n\nCursor.prototype.toJSON = function() {\n  if (this._type === 'Cursor') {\n    throw new Err.ReqlDriverError('You cannot serialize a Cursor to JSON. Retrieve data from the cursor with `toArray` or `next`');\n  }\n  else {\n    throw new Err.ReqlDriverError('You cannot serialize a '+this._type+' to JSON. Retrieve data from the cursor with `each` or `next`');\n  }\n}\n\nCursor.prototype._next = function(callback) {\n  var self = this;\n  if (self._closed === true) {\n    return Promise.reject(new Err.ReqlDriverError(\n      'You cannot call `next` on a closed '+self._type).setOperational()\n    ).nodeify(callback);\n  }\n  else if ((self._data.length === 0) && (self._canFetch === false)) {\n    return Promise.reject(new Err.ReqlDriverError(\n      'No more rows in the '+self._type.toLowerCase()).setOperational()\n    ).nodeify(callback);\n  }\n  else {\n    if ((self._data.length > 0) && (self._data[0].length > self._index)) {\n      var result = self._data[0][self._index++];\n      if (result instanceof Error) {\n        return Promise.reject(result).nodeify(callback);\n      }\n      else {\n        // This could be possible if we get back batch with just one document?\n        if (self._data[0].length === self._index) {\n          self._index = 0;\n          self._data.shift();\n          if ((self._data.length === 1)\n            && (self._canFetch === true)\n            && (self._closed === false)\n            && (self._fetching === false)) {\n              self._fetch();\n          }\n        }\n        return Promise.resolve(result).nodeify(callback);\n      }\n    }\n    else {\n      return new Promise(function(resolve, reject) {\n        self._pendingPromises.push({resolve: resolve, reject: reject});\n      }).nodeify(callback);\n    }\n  }\n}\nCursor.prototype.hasNext = function() {\n  throw new Error('The `hasNext` command has been removed in 1.13, please use `next`.')\n}\nCursor.prototype.toArray = function(callback) {\n  var self = this;\n  var p = new Promise(function(resolve, reject) {\n    var result = [];\n    var i =0;\n    self._each(function(err, data) {\n      if (err) {\n        reject(err);\n      }\n      else {\n        result.push(data);\n      }\n    }, function() {\n      resolve(result);\n    });\n  }).nodeify(callback);\n  return p;\n}\n\nCursor.prototype._fetch = function() {\n  var self = this;\n  this._fetching = true;\n\n  var p = new Promise(function(resolve, reject) {\n    self.connection._continue(self.token, resolve, reject);\n  }).then(function(response) {\n    self._push(response);\n    return null;\n  }).error(function(error) {\n    self._fetching = false;\n    self._canFetch = false;\n    self._pushError(error);\n  })\n}\n\nCursor.prototype._push = function(data) {\n  var couldfetch = this._canFetch;\n  if (data.done) this._done();\n  var response = data.response;\n  this._fetching = false;\n  // If the cursor was closed, we ignore all following response\n  if ((response.r.length > 0) && (couldfetch === true)) {\n    this._data.push(helper.makeSequence(response, this.options));\n  }\n  // this._fetching = false\n  if ((this._closed === false) && (this._canFetch) && (this._data.length <= 1)) this._fetch();\n  this._flush();\n}\n// Try to solve as many pending promises as possible\nCursor.prototype._flush = function() {\n  while ((this._pendingPromises.length > 0) && ((this._data.length > 0) || ((this._fetching === false) && (this._canFetch === false)))) {\n    var fullfiller = this._pendingPromises.shift();\n    var resolve = fullfiller.resolve;\n    var reject = fullfiller.reject;\n\n    if (this._data.length > 0) {\n      var result = this._data[0][this._index++];\n      if (result instanceof Error) {\n        reject(result);\n      }\n      else {\n        resolve(result);\n      }\n\n      if (this._data[0].length === this._index) {\n        this._index = 0;\n        this._data.shift();\n        if ((this._data.length <= 1)\n          && (this._canFetch === true)\n          && (this._closed === false)\n          && (this._fetching === false)) {\n            this._fetch();\n        }\n      }\n    }\n    else {\n      reject(new Err.ReqlDriverError('No more rows in the '+this._type.toLowerCase()).setOperational())\n    }\n  }\n}\nCursor.prototype._pushError = function(error) {\n  this._data.push([error]);\n  this._flush();\n}\n\nCursor.prototype._done = function() {\n  this._canFetch = false;\n  if (this._eventEmitter) {\n    this._eventEmitter.emit('end');\n  }\n}\n\nCursor.prototype._set = function(ar) {\n  this._fetching = false;\n  this._canFetch = false;\n  if (ar.length > 0) {\n    this._data.push(ar);\n  }\n  this._flush();\n}\n\nCursor.prototype.close = function(callback) {\n  var self = this;\n  if (self._closed === true) {\n    return self._closingPromise.nodeify(callback);\n  }\n  self._closed = true;\n\n  self._closingPromise = new Promise(function(resolve, reject) {\n    if ((self._canFetch === false) && (self._fetching === false)) {\n      resolve()\n    }\n    else { // since v0_4 (RethinkDB 2.0) we can (must) force a STOP request even if a CONTINUE query is pending\n      var endCallback = function() {\n        if (self._eventEmitter && (self._emittedEnd === false)) {\n          self._emittedEnd = true;\n          self._eventEmitter.emit('end');\n        }\n        resolve();\n      }\n      self.connection._end(self.token, endCallback, reject);\n    }\n  }).nodeify(callback);\n  return self._closingPromise;\n}\nCursor.prototype._each = function(callback, onFinish) {\n  if (this._closed === true) {\n    return callback(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());\n  }\n  var self = this;\n\n  var reject = function(err) {\n    if (err.message === 'No more rows in the '+self._type.toLowerCase()+'.') {\n      if (typeof onFinish === 'function') {\n        onFinish();\n      }\n    }\n    else {\n      callback(err);\n    }\n    return null;\n  }\n  var resolve = function(data) {\n    self._stackSize++;\n    var keepGoing = callback(null, data);\n    if (keepGoing === false) {\n      if (typeof onFinish === 'function') {\n        onFinish();\n      }\n    }\n    else {\n      if (self._closed === false) {\n        if (self._stackSize <= MAX_CALL_STACK) {\n          self._next().then(resolve).error(function(error) {\n            if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n                (error.message.match(/You cannot call `next` on a closed/) === null)) {\n              reject(error);\n            }\n          });\n        }\n        else {\n          setTimeout(function() {\n            self._stackSize = 0;\n            self._next().then(resolve).error(function(error) {\n              if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n                  (error.message.match(/You cannot call `next` on a closed/) === null)) {\n                reject(error);\n              }\n            });\n          }, 0);\n        }\n      }\n    }\n    return null;\n  }\n\n  self._next().then(resolve).error(function(error) {\n    // We can silence error when the cursor is closed as this\n    if ((error.message !== 'You cannot retrieve data from a cursor that is closed.') &&\n        (error.message.match(/You cannot call `next` on a closed/) === null)) {\n      reject(error);\n    }\n  });\n  return null;\n}\nCursor.prototype._eachAsync = function(callback) {\n  var self = this;\n  return new Promise(function(resolve, reject) {\n    self._eachAsyncInternal(callback, resolve, reject)\n  });\n}\nCursor.prototype._eachAsyncInternal = function(callback, finalResolve, finalReject) {\n  if (this._closed === true) {\n    finalReject(new Err.ReqlDriverError('You cannot retrieve data from a cursor that is closed').setOperational());\n    return;\n  }\n  var self = this;\n\n  var nextCb = function() {\n    self._stackSize++;\n    self._next().then(function(row) {\n      if (self._stackSize <= MAX_CALL_STACK) {\n        if (callback.length <= 1) {\n          Promise.resolve(callback(row)).then(nextCb)\n          return null;\n        }\n        else {\n          new Promise(function(resolve, reject) {\n            return callback(row, resolve)\n          }).then(nextCb);\n          return null;\n        }\n      }\n      else {\n        new Promise(function(resolve, reject) {\n          setTimeout(function() {\n            self._stackSize = 0;\n            if (callback.length <= 1) {\n              Promise.resolve(callback(row)).then(resolve).catch(reject);\n            }\n            else {\n              new Promise(function(resolve, reject) {\n                return callback(row, resolve)\n              }).then(resolve).catch(reject);\n              return null;\n            }\n          }, 0)\n        }).then(nextCb);\n        return null;\n      }\n    }).error(function(error) {\n      if ((error.message === 'No more rows in the '+self._type.toLowerCase()+'.') ||\n          (error.message === 'You cannot retrieve data from a cursor that is closed.') ||\n          (error.message.match(/You cannot call `next` on a closed/) !== null)) {\n        return finalResolve();\n      }\n      return finalReject(Err.setOperational(error));\n    });\n  }\n  nextCb();\n}\nCursor.prototype.eachAsync = Cursor.prototype._eachAsync;\nCursor.prototype.next = Cursor.prototype._next;\nCursor.prototype.each = Cursor.prototype._each;\nCursor.prototype._unsupportedToArray = function() {\n  throw new Error('The `toArray` method is not available on feeds.')\n}\n\nCursor.prototype._makeEmitter = function() {\n  this.next = function() {\n    throw new Err.ReqlDriverError('You cannot call `next` once you have bound listeners on the '+this._type)\n  }\n  this.each = function() {\n    throw new Err.ReqlDriverError('You cannot call `each` once you have bound listeners on the '+this._type)\n  }\n  this.eachAsync = function() {\n    throw new Err.ReqlDriverError('You cannot call `eachAsync` once you have bound listeners on the '+this._type)\n  }\n  this.toArray = function() {\n    throw new Err.ReqlDriverError('You cannot call `toArray` once you have bound listeners on the '+this._type)\n  }\n  this._eventEmitter = new EventEmitter();\n}\nCursor.prototype._eachCb = function(err, data) {\n  // We should silent things if the cursor/feed is closed\n  if (this._closed === false) {\n    if (err) {\n      this._eventEmitter.emit('error', err);\n    }\n    else {\n      this._eventEmitter.emit('data', data);\n    }\n  }\n}\n\nvar methods = [\n  'addListener',\n  'on',\n  'once',\n  'removeListener',\n  'removeAllListeners',\n  'setMaxListeners',\n  'listeners',\n  'emit'\n];\n\nfor(var i=0; i<methods.length; i++) {\n  (function(n) {\n    var method = methods[n];\n    Cursor.prototype[method] = function() {\n      var self = this;\n      if (self._eventEmitter == null) {\n        self._makeEmitter();\n        setImmediate(function() {\n          self._each(self._eachCb.bind(self), function() {\n            if (self._emittedEnd === false) {\n              self._emittedEnd = true;\n              self._eventEmitter.emit('end');\n            }\n          });\n        });\n      }\n      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n      self._eventEmitter[method].apply(self._eventEmitter, _args);\n    };\n  })(i);\n}\n\nmodule.exports = Cursor;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/stream.js":"var Readable = require('stream').Readable;\nvar Cursor = require(__dirname+'/cursor.js');\nvar util = require('util');\n\n// Experimental, but should work fine.\nfunction ReadableStream(options, cursor) {\n  if (cursor) this._cursor = cursor;\n  this._pending = 0; // How many time we called _read while no cursor was available\n  this._index = 0;\n  this._maxRecursion = 1000; // Hardcoded\n  this._highWaterMark = options.highWaterMark;\n  this._closed = false;\n\n  Readable.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n};\nutil.inherits(ReadableStream, Readable);\n\n\nReadableStream.prototype._setCursor = function(cursor) {\n  if (cursor instanceof Cursor === false) {\n    this.emit('error', new Error('Cannot create a stream on a single value.'));\n    this.push(null);\n    return this;\n  }\n  this._cursor = cursor;\n  this._fetchAndDecrement();\n}\nReadableStream.prototype._read = function(size) {\n  this._count++;\n  if (this._cursor === undefined) {\n    this._pending++;\n    return;\n  }\n\n  this._recursion = 0;\n  this._fetch();\n}\n\n//TODO: Refactor with _fetch?\nReadableStream.prototype._fetchAndDecrement = function() {\n  var self = this;\n  self._pending--;\n  if (self._pending < 0 || self._closed === true) {\n    return;\n  }\n\n  if (self._cursor._closed === true) {\n    self.push(null);\n  }\n  else {\n    self._cursor._next().then(function(data) {\n      // Silently drop null values for now\n      if (data === null) {\n        if (self._recursion++ === self._maxRecursion) {\n          //Avoid maximum call stack errors\n          process.nextTick(function() {\n            self._fetchAndDecrement();\n          });\n        }\n        else {\n          self._fetchAndDecrement();\n        }\n      }\n      else {\n        if (self.push(data) !== false) {\n          if (self._recursion++ === self._maxRecursion) {\n            process.nextTick(function() {\n              self._fetchAndDecrement();\n            });\n          }\n          else {\n            self._fetchAndDecrement();\n          }\n        }\n      }\n      return null;\n    }).error(function(error) {\n      if (error.message.match(/No more rows in the/)) {\n        self.push(null);\n      }\n      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {\n        // if the user call `close`, the cursor may reject pending requests. We just\n        // ignore them here.\n      }\n      else {\n        self.emit('error', error);\n        self.push(null);\n      }\n    });\n  }\n}\n\nReadableStream.prototype._fetch = function() {\n  var self = this;\n  if (self._closed === true) {\n    return;\n  }\n  if (self._cursor._closed === true) {\n    self.push(null);\n  }\n  else {\n    self._cursor._next().then(function(data) {\n      if (self._closed === true) {\n        return;\n      }\n      // Silently drop null values for now\n      if (data === null) {\n        if (self._recursion++ === self._maxRecursion) {\n          process.nextTick(function() {\n            self._fetch();\n          });\n        }\n        else {\n          self._fetch();\n        }\n      }\n      else {\n        if (self.push(data) !== false) {\n          if (self._recursion++ === self._maxRecursion) {\n            process.nextTick(function() {\n              self._fetch();\n            });\n          }\n          else {\n            self._fetch();\n          }\n        }\n      }\n      return null;\n    }).error(function(error) {\n      if (error.message.match(/No more rows in the/)) {\n        self.push(null);\n      }\n      else if (error.message === 'You cannot retrieve data from a cursor that is closed.') {\n        // if the user call `close`, the cursor may reject pending requests. We just\n        // ignore them here.\n      }\n      else {\n        self.emit('error', error);\n        self.push(null);\n      }\n    });\n  }\n}\n\n\nReadableStream.prototype.close = function() {\n  this._closed = true;\n  this.push(null);\n  return this._cursor.close();\n}\n\nmodule.exports = ReadableStream;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/metadata.js":"// Metadata we keep per query\nfunction Metadata(resolve, reject, query, options) {\n  this.resolve = resolve;\n  this.reject = reject;\n  this.query = query; // The query in case we have to build a backtrace\n  this.options = options || {};\n  this.cursor = false;\n}\n\nMetadata.prototype.setCursor = function() {\n  this.cursor = true;\n}\n\nMetadata.prototype.setEnd = function(resolve, reject) {\n  this.endResolve = resolve;\n  this.endReject = reject;\n}\n\nMetadata.prototype.setCallbacks = function(resolve, reject) {\n  this.resolve = resolve;\n  this.reject = reject;\n}\nMetadata.prototype.removeCallbacks = function() {\n  this.resolve = null;\n  this.reject = null;\n}\nMetadata.prototype.removeEndCallbacks = function() {\n  this.endResolve = null;\n  this.endReject = null;\n}\n\nmodule.exports = Metadata;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/term.js":"var Promise = require('bluebird');\nvar protodef = require(__dirname+'/protodef.js');\nvar termTypes = protodef.Term.TermType;\n\nvar Error = require(__dirname+'/error.js');\nvar helper = require(__dirname+'/helper.js');\nvar ReadableStream = require(__dirname+'/stream.js');\nvar WritableStream = require(__dirname+'/writable_stream.js');\nvar TransformStream = require(__dirname+'/transform_stream.js');\n\nfunction Term(r, value, error) {\n  var self = this;\n  var term = function(field) {\n    if (Term.prototype._fastArity(arguments.length, 1) === false) {\n      var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n      Term.prototype._arity(_args, 1, '(...)', self);\n    }\n    return term.bracket(field);\n  }\n  helper.changeProto(term, self);\n\n  if (value === undefined) {\n    term._query = [];\n  }\n  else {\n    term._query = value;\n  }\n  term._r = r; // Keep a reference to r for global settings\n\n  if (error !== undefined) {\n    term._error = error;\n    term._frames = [];\n  }\n\n  return term;\n}\n\n// run([connection][, options][, callback])\nTerm.prototype.run = function(connection, options, callback) {\n  var self = this;\n\n  if (self._error != null) {\n    var error = new Error.ReqlRuntimeError(self._error, self._query, {b: self._frames});\n    return Promise.reject(error);\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    else {\n      if (!helper.isPlainObject(options)) options = {};\n    }\n\n    if (connection._isOpen() !== true) {\n      return new Promise(function(resolve, reject) {\n        reject(new Error.ReqlDriverError('`run` was called with a closed connection', self._query).setOperational());\n      });\n    }\n    var p = new Promise(function(resolve, reject) {\n      var token = connection._getToken();\n\n      var query = [protodef.Query.QueryType.START];\n      query.push(self._query);\n\n      var _options = {};\n      var sendOptions = false;\n      if (connection.db != null) {\n        sendOptions = true;\n        _options.db = self._r.db(connection.db)._query;\n      }\n\n      if (self._r.arrayLimit != null) {\n        sendOptions = true;\n        _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;\n      };\n\n\n      var keepGoing = true; // we need it just to avoir calling resolve/reject multiple times\n      helper.loopKeys(options, function(options, key) {\n        if (keepGoing === true) {\n          if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||\n            (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||\n            (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||\n            (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {\n\n            sendOptions = true;\n            if (key === 'db') {\n              _options[key] = self._r.db(options[key])._query;\n            }\n            else if (self._translateArgs.hasOwnProperty(key)) {\n              _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query;\n            }\n            else {\n              _options[key] = new Term(self._r).expr(options[key])._query;\n            }\n          }\n          else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&\n              (key !== 'binaryFormat') && (key !== 'cursor') &&\n              (key !== 'readable') && (key !== 'writable') &&\n              (key !== 'transform') && (key !== 'stream') &&\n              (key !== 'highWaterMark')) {\n            reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <bool>, cursor <bool>, stream <bool>'));\n            keepGoing = false;\n          }\n        }\n      });\n\n      if (keepGoing === false) {\n        connection.emit('release');\n        return // The promise was rejected in the loopKeys\n      }\n\n      if (sendOptions === true) {\n        query.push(_options);\n      }\n      connection._send(query, token, resolve, reject, self._query, options);\n    }).nodeify(callback);\n  }\n  else {\n    var poolMaster = self._r.getPoolMaster(); // if self._r is defined, so is self._r.getPool()\n    if (!poolMaster) {\n      throw new Error.ReqlDriverError('`run` was called without a connection and no pool has been created', self._query);\n    }\n    else {\n      if (typeof connection === 'function') {\n        // run(callback);\n        callback = connection;\n        options = {};\n      }\n      else if (helper.isPlainObject(connection)) {\n        // run(options[, callback])\n        callback = options;\n        options = connection;\n      }\n      else {\n        options = {};\n      }\n\n\n      var p = new Promise(function(resolve, reject) {\n        poolMaster.getConnection().then(function(connection) {\n          var token = connection._getToken();\n          var query = [protodef.Query.QueryType.START];\n          query.push(self._query);\n\n          var _options = {};\n          var sendOptions = false;\n          if (connection.db != null) {\n            sendOptions = true;\n            _options.db = self._r.db(connection.db)._query;\n          }\n          if (self._r.arrayLimit != null) {\n            sendOptions = true;\n            _options[self._translateArgs['arrayLimit']] = self._r.arrayLimit;\n          };\n\n          var keepGoing = true;\n          helper.loopKeys(options, function(options, key) {\n            if (keepGoing === true) {\n              if ((key === 'readMode') || (key === 'durability') || (key === 'db') ||\n                  (key === 'noreply') || (key === 'arrayLimit') || (key === 'profile') ||\n                  (key === 'minBatchRows') || (key === 'maxBatchRows') || (key === 'maxBatchBytes') ||\n                  (key === 'maxBatchSeconds') || (key === 'firstBatchScaledownFactor')) {\n\n\n                sendOptions = true;\n                if (key === 'db') {\n                  _options[key] = self._r.db(options[key])._query;\n                }\n                else if (self._translateArgs.hasOwnProperty(key)) {\n                  _options[self._translateArgs[key]] = new Term(self._r).expr(options[key])._query\n                }\n                else {\n                  _options[key] = new Term(self._r).expr(options[key])._query\n                }\n              }\n              else if ((key !== 'timeFormat') && (key !== 'groupFormat') &&\n                  (key !== 'binaryFormat') && (key !== 'cursor') &&\n                  (key !== 'readable') && (key !== 'writable') &&\n                  (key !== 'transform') && (key !== 'stream') &&\n                  (key !== 'highWaterMark')) {\n\n                setTimeout( function() {\n                  reject(new Error.ReqlDriverError('Unrecognized option `'+key+'` in `run`. Available options are readMode <string>, durability <string>, noreply <bool>, timeFormat <string>, groupFormat: <string>, profile <bool>, binaryFormat <string>, cursor <bool>, stream <bool>'));\n                }, 0);\n                keepGoing = false;\n                return false;\n              }\n            }\n          });\n\n          if (keepGoing === false) {\n            connection.emit('release');\n            return // The promise was rejected in the loopKeys\n          }\n\n          if (sendOptions === true) {\n            query.push(_options);\n          }\n          connection._send(query, token, resolve, reject, self._query, options);\n        }).error(function(error) {\n          reject(error);\n        });\n      }).nodeify(callback);\n    }\n  }\n\n  //if (options.noreply) return self; // Do not return a promise if the user ask for no reply.\n\n  return p;\n}\n\nTerm.prototype.toStream = function(connection, options) {\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    if (helper.isPlainObject(options) === false) {\n      options = {};\n    }\n    if (options.readable === true) {\n      return this._toReadableStream(connection, options);\n    }\n    else if (options.writable === true) {\n      return this._toWritableStream(connection, options);\n    }\n    else if (options.transform === true) {\n      return this._toTransformStream(connection, options);\n    }\n    else {\n      return this._toReadableStream(connection, options);\n    }\n  }\n  else {\n    options = connection;\n    if (helper.isPlainObject(options) === false) {\n      options = {};\n    }\n    if (options.readable === true) {\n      return this._toReadableStream(options);\n    }\n    else if (options.writable === true) {\n      return this._toWritableStream(options);\n    }\n    else if (options.transform === true) {\n      return this._toTransformStream(options);\n    }\n    else {\n      return this._toReadableStream(options);\n    }\n  }\n}\n\nTerm.prototype._toReadableStream = function(connection, options) {\n  var stream;\n\n  var _options = {};\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    //toStream make sure that options is an object\n    helper.loopKeys(options, function(obj, key) {\n      _options[key] = obj[key];\n    });\n    _options.cursor = true;\n    stream = new ReadableStream(_options);\n    this.run(connection, _options).then(function(cursor) {\n      stream._setCursor(cursor);\n      return null;\n    }).error(function(error) {\n      stream.emit('error', error);\n    });\n  }\n  else {\n    helper.loopKeys(connection, function(obj, key) {\n      _options[key] = obj[key];\n    });\n    _options.cursor = true;\n    stream = new ReadableStream(_options);\n    this.run(_options).then(function(cursor) {\n      stream._setCursor(cursor);\n      return null;\n    }).error(function(error) {\n      stream.emit('error', error);\n    });\n  }\n  return stream;\n}\n\nTerm.prototype._toWritableStream = function(connection, options) {\n  if (this._query[0] !== termTypes.TABLE) {\n    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    return new WritableStream(this, options, connection);\n  }\n  else {\n    return new WritableStream(this, connection);\n  }\n}\nTerm.prototype._toTransformStream = function(connection, options) {\n  if (this._query[0] !== termTypes.TABLE) {\n    throw new Error.ReqlDriverError('Cannot create a writable stream on something else than a table.');\n  }\n\n  if (helper.isPlainObject(connection) && (typeof connection._isConnection === 'function') && (connection._isConnection() === true)) {\n    return new TransformStream(this, options, connection);\n  }\n  else {\n    return new TransformStream(this, connection);\n  }\n}\n\n\n// Manipulating databases\nTerm.prototype.dbCreate = function(db) {\n  // Check for arity is done in r.prototype.dbCreate\n  this._noPrefix(this, 'dbCreate');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_CREATE);\n  var args = [new Term(this._r).expr(db)._query]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dbDrop = function(db) {\n  this._noPrefix(this, 'dbDrop');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_DROP);\n  var args = [new Term(this._r).expr(db)._query]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dbList = function() {\n  this._noPrefix(this, 'dbList');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB_LIST)\n  return term;\n}\n\n// Manipulating Tables\nTerm.prototype.tableCreate = function(table, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'tableCreate', self);\n  }\n\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.TABLE_CREATE)\n\n  var args = [];\n  if (Array.isArray(self._query) && (self._query.length > 0)) {\n    args.push(self); // Push db\n  }\n  args.push(new Term(self._r).expr(table))\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // Check for non valid key\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'primaryKey')\n          && (key !== 'durability')\n          && (key !== 'shards')\n          && (key !== 'replicas')\n          && (key !== 'primaryReplicaTag')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `tableCreate`', self._query, 'Available options are primaryKey <string>, durability <string>, shards <number>, replicas <number/object>, primaryReplicaTag <object>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\nTerm.prototype.tableDrop = function(table) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'tableDrop', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TABLE_DROP)\n\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this); // push db\n  }\n  args.push(new Term(this._r).expr(table))\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.tableList = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'tableList', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TABLE_LIST);\n\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexList = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'indexList', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_LIST);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexCreate = function(name, fn, options) {\n  if (this._fastArityRange(arguments.length, 1, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 3, 'indexCreate', this);\n  }\n\n  if ((options == null) && (helper.isPlainObject(fn))) {\n    options = fn;\n    fn = undefined;\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_CREATE);\n  var args = [this];\n  args.push(new Term(this._r).expr(name));\n  if (typeof fn !== 'undefined') args.push(new Term(this._r).expr(fn)._wrap());\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // There is no need to translate here\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'multi') && (key !== 'geo')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexCreate`', self._query, 'Available option is multi <bool> and geo <bool>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(options)._query);\n  }\n  return term;\n}\nTerm.prototype.indexDrop = function(name) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'indexDrop', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_DROP);\n  var args = [this, new Term(this._r).expr(name)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.indexStatus = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_STATUS);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexWait = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_WAIT);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexRename = function(oldName, newName, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'indexRename', self);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INDEX_RENAME);\n  var args = [this, new Term(this._r).expr(oldName), new Term(this._r).expr(newName)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'overwrite') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `indexRename`', self._query, 'Available options are overwrite <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n\n  return term;\n}\nTerm.prototype.changes = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'changes', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.CHANGES);\n  var args = [self];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'squash') && (key !== 'includeStates') && (key !== 'includeTypes')\n          && (key !== 'includeInitial') && (key !== 'includeOffsets')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `changes`', self._query,\n            'Available options are squash <bool>, includeInitial <bool>, includeStates <bool>, includeOffsets <bool>, includeTypes <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n// Writing data\nTerm.prototype.insert = function(documents, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'insert', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.INSERT);\n  var args = [self, new Term(self._r).expr(documents)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'conflict')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `insert`', self._query, 'Available options are returnChanges <bool>, durability <string>, conflict <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.update = function(newValue, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'update', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.UPDATE);\n  var args = [self, new Term(self._r).expr(newValue)._wrap()];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `update`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.replace = function(newValue, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'replace', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.REPLACE);\n  var args = [self, new Term(self._r).expr(newValue)._wrap()];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability') && (key !== 'nonAtomic')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `replace`', self._query, 'Available options are returnChanges <bool>, durability <string>, nonAtomic <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.delete = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'delete', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.DELETE);\n  var args = [self];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'returnChanges') && (key !== 'durability')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `delete`', self._query, 'Available options are returnChanges <bool>, durability <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.sync = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'sync', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SYNC)\n  var args = [this._query];\n  term._fillArgs(args);\n  return term;\n}\n\n// Selecting data\nTerm.prototype.db = function(db) {\n  this._noPrefix(this, 'db');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'db', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DB)\n  var args = [new Term(this._r).expr(db)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.table = function(table, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'table', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.TABLE)\n\n  var args = [];\n  if (Array.isArray(self._query) && (self._query.length > 0)) {\n    args.push(self);\n  }\n  args.push(new Term(self._r).expr(table))\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'readMode') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `table`', self._query, 'Available option is readMode <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.get = function(primaryKey) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'get', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET);\n  var args = [this, new Term(this._r).expr(primaryKey)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.getAll = function() {\n  // We explicitly _args here, so fastArityRange is not useful\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_ALL);\n\n  var args = [];\n  args.push(this);\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else if (_args.length > 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1]))\n    term._fillArgs(args);\n  } else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.between = function(start, end, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'between', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.BETWEEN);\n  var args = [self, new Term(self._r).expr(start), new Term(self._r).expr(end)]\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'leftBound') && (key !== 'rightBound')){\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `between`', self._query, 'Available options are index <string>, leftBound <string>, rightBound <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.minval = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MINVAL);\n  return term;\n}\nTerm.prototype.maxval = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAXVAL);\n  return term;\n}\n\nTerm.prototype.filter = function(filter, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'filter', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.FILTER);\n  var args = [self, new Term(self._r).expr(filter)._wrap()]\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'default') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `filter`', self._query, 'Available option is filter');\n      }\n    })\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n// Joins\nTerm.prototype.innerJoin = function(sequence, predicate) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'innerJoin', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INNER_JOIN);\n  var args = [this._query];\n  args.push(new Term(this._r).expr(sequence)._query);\n  args.push(new Term(this._r).expr(predicate)._wrap()._query);\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.outerJoin = function(sequence, predicate) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'outerJoin', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OUTER_JOIN);\n  var args = [this];\n  args.push(new Term(this._r).expr(sequence));\n  args.push(new Term(this._r).expr(predicate)._wrap());\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.eqJoin = function(rightKey, sequence, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 2, 3, 'eqJoin', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.EQ_JOIN);\n  var args = [self];\n  args.push(new Term(self._r).expr(rightKey)._wrap());\n  args.push(new Term(self._r).expr(sequence));\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'ordered')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `eqJoin`', self._query, 'Available options are index <string>, ordered <boolean>');\n      }\n    })\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.zip = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'zip', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ZIP);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n// Transformation\nTerm.prototype.map = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'map', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAP);\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  // Make sure that we don't push undefined if no argument is passed to map,\n  // in which case the server will handle the case and return an error.\n  if (_args.length> 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())\n  }\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.withFields = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'withFields', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.WITH_FIELDS);\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.concatMap = function(transformation) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'concatMap', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONCAT_MAP);\n  var args = [this];\n  args.push(new Term(this._r).expr(transformation)._wrap())\n  term._fillArgs(args);\n\n  return term;\n}\nTerm.prototype.orderBy = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'orderBy', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ORDER_BY);\n\n  var args = [this];\n  for(var i=0; i<_args.length-1; i++) {\n    if ((_args[i] instanceof Term) &&\n        ((_args[i]._query[0] === termTypes.DESC) || (_args[i]._query[0] === termTypes.ASC))) {\n      args.push(new Term(this._r).expr(_args[i]))\n    }\n    else {\n      args.push(new Term(this._r).expr(_args[i])._wrap())\n    }\n  }\n  // We actually don't need to make the difference here, but...\n  if ((_args.length > 0) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].index !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else {\n    if ((_args[_args.length-1] instanceof Term) &&\n      ((_args[_args.length-1]._query[0] === termTypes.DESC) || (_args[_args.length-1]._query[0] === termTypes.ASC))) {\n      args.push(new Term(this._r).expr(_args[_args.length-1]))\n    }\n    else {\n      args.push(new Term(this._r).expr(_args[_args.length-1])._wrap())\n    }\n    term._fillArgs(args);\n  }\n  return term;\n\n}\nTerm.prototype.desc = function(field) {\n  this._noPrefix(this, 'desc');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'desc', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DESC)\n  var args = [new Term(this._r).expr(field)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.asc = function(field) {\n  this._noPrefix(this, 'asc');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'asc', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ASC)\n  var args = [new Term(this._r).expr(field)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.skip = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'skip', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SKIP)\n  var args = [this, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.limit = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'limit', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LIMIT)\n  var args = [this, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.slice = function(start, end, options) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 3, 'slice', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SLICE);\n\n  var args = [];\n  args.push(this);\n  args.push(new Term(this._r).expr(start));\n\n  if ((end !== undefined) && (options !== undefined)) {\n    args.push(new Term(this._r).expr(end));\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  else if ((end !== undefined) && (options === undefined)) {\n    if (helper.isPlainObject(end) === false) {\n      args.push(new Term(this._r).expr(end));\n      term._fillArgs(args);\n    }\n    else {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(end))._query);\n    }\n  }\n  else { // end and options are both undefined\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.nth = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'nth', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NTH)\n  var args = [this._query, new Term(this._r).expr(value)]\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.offsetsOf = function(predicate) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'indexesOf', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OFFSETS_OF)\n  var args = [this, new Term(this._r).expr(predicate)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.indexesOf = Term.prototype.offsetsOf;\n\nTerm.prototype.isEmpty = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'isEmpty', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IS_EMPTY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.union = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UNION)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  if ((_args.length > 1) && (helper.isPlainObject(_args[_args.length-1])) && (_args[_args.length-1].interleave !== undefined)) {\n    term._fillArgs(args);\n    term._query.push(new Term(this._r).expr(translateOptions(_args[_args.length-1]))._query);\n  }\n  else if (_args.length > 0) {\n    args.push(new Term(this._r).expr(_args[_args.length-1]))\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.sample = function(size) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'sample', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SAMPLE)\n  var args = [this, new Term(this._r).expr(size)];\n  term._fillArgs(args);\n  return term;\n}\n\n// Aggregations\nTerm.prototype.reduce = function(func) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'reduce', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.REDUCE)\n  var args = [this, new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.count = function(filter) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'count', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.COUNT);\n  var args = [];\n  args.push(this);\n  if (filter !== undefined) {\n    args.push(new Term(this._r).expr(filter)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.distinct = function(options) {\n  var self= this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'distinct', self);\n  }\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.DISTINCT)\n  var args = [self];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    var keepGoing = true;\n    helper.loopKeys(options, function(obj, key) {\n      if ((keepGoing === true) && (key !== 'index')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distinct`', self._query, 'Available option is index: <string>');\n        keepGoing = false;\n      }\n    });\n    if (keepGoing === true) {\n      term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n    }\n  }\n\n  return term;\n}\nTerm.prototype.group = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var self = this;\n  self._arityRange(_args, 1, Infinity, 'group', self);\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.GROUP);\n  var args = [self];\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(self._r).expr(_args[i])._wrap())\n  }\n  if (_args.length > 0) {\n    if (helper.isPlainObject(_args[_args.length-1])) {\n      helper.loopKeys(_args[_args.length-1], function(obj, key) {\n         if ((key !== 'index')\n        && (key !==  'multi')) {\n          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `group`', self._query, 'Available options are index: <string>, multi <boolean>');\n        }\n      });\n      term._fillArgs(args);\n      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);\n    }\n    else {\n      args.push(new Term(self._r).expr(_args[_args.length-1])._wrap())\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n\n  return term;\n}\nTerm.prototype.split = function(separator, max) {\n  if (this._fastArityRange(arguments.length, 0, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 2, 'split', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SPLIT)\n  var args = [this];\n  if (separator !== undefined) {\n    args.push(new Term(this._r).expr(separator))\n    if (max !== undefined) {\n      args.push(new Term(this._r).expr(max))\n    }\n  }\n  term._fillArgs(args);\n\n  return term;\n}\n\nTerm.prototype.ungroup = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'ungroup', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UNGROUP)\n  var args = [this._query];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.contains = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'contains', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONTAINS)\n  var args = [this._query];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i])._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.sum = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'sum', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUM);\n  var args = [this];\n  if (field !== undefined) {\n    args.push(new Term(this._r).expr(field)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.avg = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'avg', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.AVG)\n  var args = [this];\n  if (field !== undefined) {\n    args.push(new Term(this._r).expr(field)._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.min = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'min', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MIN)\n  var args = [this];\n  if (field !== undefined) {\n    if (helper.isPlainObject(field)) {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(field))._query);\n    }\n    else {\n      args.push(new Term(this._r).expr(field)._wrap());\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.max = function(field) {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'max', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAX)\n  var args = [this];\n  if (field !== undefined) {\n    if (helper.isPlainObject(field)) {\n      term._fillArgs(args);\n      term._query.push(new Term(this._r).expr(translateOptions(field))._query);\n    }\n    else {\n      args.push(new Term(this._r).expr(field)._wrap())\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.fold = function(base, func, options) {\n  if (this._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 2, 3, 'range', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FOLD)\n  var args = [this, new Term(this._r).expr(base), new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'emit') && (key !== 'finalEmit')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `fold`. Available options are emit <function>, finalEmit <function>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\n\n\n// Document manipulation\nTerm.prototype.row = function() {\n  this._noPrefix(this, 'row');\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'r.row', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IMPLICIT_VAR)\n  return term;\n}\nTerm.prototype.pluck = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'pluck', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.PLUCK)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.without = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'without', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.WITHOUT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.merge = function(arg) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'merge', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MERGE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i])._wrap())\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.literal = function(obj) {\n  this._noPrefix(this, 'literal');\n  // The test for arity is performed in r.literal\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LITERAL);\n  if (arguments.length > 0) {\n    var args = [new Term(this._r).expr(obj)];\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.append = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'append', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.APPEND)\n  var args = [this, new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.prepend = function(value) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'prepend', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.PREPEND)\n  var args = [this, new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.difference = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'difference', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DIFFERENCE)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setInsert = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setInsert', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_INSERT)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setUnion = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setUnion', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_UNION)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setIntersection = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setIntersection', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_INTERSECTION)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.setDifference = function(other) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'setDifference', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SET_DIFFERENCE)\n  var args = [this, new Term(this._r).expr(other)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.getField = function(field) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, '(...)', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_FIELD)\n  var args = [this, new Term(this._r).expr(field)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.bracket = function(field) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, '(...)', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.BRACKET)\n  var args = [this, new Term(this._r).expr(field)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.hasFields = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'hasFields', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HAS_FIELDS)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n\n}\nTerm.prototype.insertAt = function(index, value) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'insertAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INSERT_AT)\n  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(value)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.spliceAt = function(index, array) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'spliceAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SPLICE_AT)\n  var args = [this, new Term(this._r).expr(index), new Term(this._r).expr(array)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.deleteAt = function(start, end) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'deleteAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DELETE_AT);\n  var args = [this, new Term(this._r).expr(start)];\n  if (end !== undefined) {\n    args.push(new Term(this._r).expr(end))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.changeAt = function(index, value) {\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'changeAt', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CHANGE_AT);\n  var args = [this];\n  args.push(new Term(this._r).expr(index))\n  args.push(new Term(this._r).expr(value))\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.keys = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'keys', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.KEYS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.values = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'keys', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.VALUES)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.object = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'object');\n  this._arityRange(_args, 0, Infinity, 'object', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OBJECT)\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n// String\nTerm.prototype.match = function(regex) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'match', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MATCH)\n  var args = [this, new Term(this._r).expr(regex)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.upcase = function(regex) {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'upcase', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UPCASE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.downcase = function(regex) {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'upcase', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DOWNCASE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n\n\n\n// Math and Logic\nTerm.prototype.add = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'add', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ADD)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.sub = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'sub', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUB)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.mul = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'mul', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MUL)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.div = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'div', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DIV)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.mod = function(b) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'mod', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MOD)\n  var args = [this, new Term(this._r).expr(b)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.and = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.AND)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.or = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.OR)\n  var args = [];\n  if (!Array.isArray(this._query) || (this._query.length > 0)) {\n    args.push(this);\n  }\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.eq = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'eq', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.EQ)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ne = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'ne', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.gt = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'gt', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ge = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'ge', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.lt = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'lt', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LT)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.le = function(other) {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'le', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LE)\n  var args = [this];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.not = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'not', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOT)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.random = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  var self = this;\n  self._noPrefix(this, 'random');\n  self._arityRange(_args, 0, 3, 'random', self);\n\n  var term = new Term(self._r);\n  term._query.push(termTypes.RANDOM);\n\n  var args = [];\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(self._r).expr(_args[i]))\n  }\n  if (_args.length > 0) {\n    if (helper.isPlainObject(_args[_args.length-1])) {\n      helper.loopKeys(_args[_args.length-1], function(obj, key) {\n        if (key !== 'float') {\n          throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `random`', self._query, 'Available option is float: <boolean>');\n        }\n      });\n      term._fillArgs(args);\n      term._query.push(new Term(self._r).expr(translateOptions(_args[_args.length-1]))._query);\n    }\n    else {\n      args.push(new Term(self._r).expr(_args[_args.length-1]))\n      term._fillArgs(args);\n    }\n  }\n  else {\n    term._fillArgs(args);\n  }\n  return term;\n}\nTerm.prototype.floor = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'floor', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FLOOR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ceil = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'ceil', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.CEIL)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.round = function() {\n  if (this._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 0, 1, 'round', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ROUND)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\n// Dates and times\nTerm.prototype.now = function() {\n  this._noPrefix(this, 'now');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOW)\n  return term;\n}\nTerm.prototype.time = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'time');\n  // Special check for arity\n  var foundArgs = false;\n  for(var i=0; i<_args.length; i++) {\n    if ((_args[i] instanceof Term) && (_args[i]._query[0] === termTypes.ARGS)) {\n      foundArgs = true;\n      break;\n    }\n  }\n  if (foundArgs === false) {\n    if ((_args.length !== 4) && (_args.length !== 7)) {\n      throw new Error.ReqlDriverError('`r.time` called with '+_args.length+' argument'+((_args.length>1)?'s':''), null, '`r.time` takes 4 or 7 arguments');\n    }\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIME)\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.epochTime = function(epochTime) {\n  this._noPrefix(this, 'epochTime');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.EPOCH_TIME)\n  var args = [new Term(this._r).expr(epochTime)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.ISO8601 = function(isoTime, options) {\n  this._noPrefix(this, 'ISO8601');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'ISO8601', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ISO8601)\n  var args = [new Term(this._r).expr(isoTime)._query];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'defaultTimezone') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `ISO8601`. Available options are primaryKey <string>, durability <string>, datancenter <string>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\nTerm.prototype.inTimezone = function(timezone) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'inTimezone', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.IN_TIMEZONE)\n  var args = [this, new Term(this._r).expr(timezone)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.timezone = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'timezone', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIMEZONE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.during = function(left, right, options) {\n  if (this._fastArityRange(arguments.length, 2, 3) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 2, 3, 'during', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DURING);\n  var args = [];\n  args.push(this);\n  args.push(new Term(this._r).expr(left));\n  args.push(new Term(this._r).expr(right));\n\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.date = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'date', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DATE)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.timeOfDay = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'timeOfDay', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TIME_OF_DAY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.year = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'year', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.YEAR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.month = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'month', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MONTH)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.day = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'day', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dayOfYear = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'dayOfYear', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY_OF_YEAR)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.dayOfWeek = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'dayOfWeek', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DAY_OF_WEEK)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.hours = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'hours', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HOURS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.minutes = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'minutes', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.MINUTES)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.seconds = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'seconds', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.SECONDS)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toISO8601 = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toISO8601', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_ISO8601)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toEpochTime = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toEpochTime', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_EPOCH_TIME)\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.monday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MONDAY);\n  return term;\n}\nTerm.prototype.tuesday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.TUESDAY);\n  return term;\n}\nTerm.prototype.wednesday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.WEDNESDAY);\n  return term;\n}\nTerm.prototype.thursday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.THURSDAY);\n  return term;\n}\nTerm.prototype.friday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.FRIDAY);\n  return term;\n}\nTerm.prototype.saturday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SATURDAY);\n  return term;\n}\nTerm.prototype.sunday = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SUNDAY);\n  return term;\n}\n\nTerm.prototype.january = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JANUARY);\n  return term;\n}\nTerm.prototype.february = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.FEBRUARY);\n  return term;\n}\nTerm.prototype.march = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MARCH);\n  return term;\n}\nTerm.prototype.april = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.APRIL);\n  return term;\n}\nTerm.prototype.may = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.MAY);\n  return term;\n}\nTerm.prototype.june = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JUNE);\n  return term;\n}\nTerm.prototype.july = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.JULY);\n  return term;\n}\nTerm.prototype.august = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.AUGUST);\n  return term;\n}\nTerm.prototype.september = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.SEPTEMBER);\n  return term;\n}\nTerm.prototype.october = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.OCTOBER);\n  return term;\n}\nTerm.prototype.november = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.NOVEMBER);\n  return term;\n}\nTerm.prototype.december = function() {\n  var term = new Term(this._r);\n  term._query.push(termTypes.DECEMBER);\n  return term;\n}\n\n\nTerm.prototype.args = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._noPrefix(this, 'args');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.ARGS);\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.do = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 1, Infinity, 'do', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FUNCALL);\n  var args = [new Term(this._r).expr(_args[_args.length-1])._wrap()._query];\n  args.push(this);\n  for(var i=0; i<_args.length-1; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\n\nTerm.prototype.branch = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  this._arityRange(_args, 2, Infinity, '', this);\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.BRANCH)\n  var args = [];\n  args.push(this);\n  for(var i=0; i<_len; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.forEach = function(func) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'forEach', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.FOR_EACH);\n  var args = [this, new Term(this._r).expr(func)._wrap()];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.default = function(expression) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'default', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.DEFAULT);\n  var args = [this, new Term(this._r).expr(expression)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.expr = function(expression, nestingLevel) {\n  var self = this;\n  self._noPrefix(self, 'expr');\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'expr', self);\n  }\n\n  // undefined will be caught in the last else\n  var ar, obj;\n\n  if (expression === undefined) {\n    var error = 'Cannot convert `undefined` with r.expr()';\n    return new Term(self._r, expression, error);\n  }\n\n  var _nestingLevel = nestingLevel;\n  if (_nestingLevel == null) {\n    _nestingLevel = self._r.nestingLevel;\n  }\n  //if (nestingLevel == null) nestingLevel = self._r.nestingLevel;\n  if (_nestingLevel < 0) throw new Error.ReqlDriverError('Nesting depth limit exceeded.\\nYou probably have a circular reference somewhere')\n\n  if (expression instanceof Term) {\n    return expression;\n  }\n  else if (expression instanceof Function) {\n    return new Func(self._r, expression);\n  }\n  else if (expression instanceof Date) {\n    return new Term(self._r).ISO8601(expression.toISOString())\n  }\n  else if (Array.isArray(expression)) {\n    var term = new Term(self._r);\n    term._query.push(termTypes.MAKE_ARRAY);\n\n    var args = [];\n    for(var i=0; i<expression.length; i++) {\n      args.push(new Term(self._r).expr(expression[i], _nestingLevel-1))\n    }\n    term._fillArgs(args);\n    return term;\n  }\n  else if (expression instanceof Buffer) {\n    return self._r.binary(expression);\n  }\n  else if (helper.isPlainObject(expression)) {\n    var term = new Term(self._r);\n    var optArgs = {};\n    var foundError = false;\n    helper.loopKeys(expression, function(expression, key) {\n      if (expression[key] !== undefined) {\n        var optArg = new Term(self._r).expr(expression[key], _nestingLevel-1);\n        if (optArg instanceof Term && !foundError && optArg._error != null) {\n          foundError = true;\n          term._error = optArg._error;\n          term._frames = [key].concat(optArg._frames);\n        }\n        optArgs[key] = optArg._query;\n      }\n    });\n    term._query = optArgs;\n    return term;\n  }\n  else { // Primitive\n    if (expression === null) {\n      return new Term(self._r, null, expression);\n    }\n    else if (typeof expression === 'string') {\n      return new Term(self._r, expression);\n    }\n    else if (typeof expression === 'number') {\n      if (expression !== expression) {\n        var error = 'Cannot convert `NaN` to JSON';\n        return new Term(self._r, expression, error);\n      }\n      else if (!isFinite(expression)) {\n        var error = 'Cannot convert `Infinity` to JSON';\n        return new Term(self._r, expression, error);\n      }\n      return new Term(self._r, expression);\n    }\n    else if (typeof expression === 'boolean') {\n      return new Term(self._r, expression);\n    }\n    else {\n      self._error = new Error.ReqlDriverError('Cannot convert `'+expression+'` to datum.');\n      self._frames = [];\n    }\n  }\n  return self;\n}\n\nTerm.prototype.binary = function(bin) {\n  this._noPrefix(this, 'binary');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'binary', this);\n  }\n\n  var term;\n  if (bin instanceof Buffer) {\n    // We could use BINARY, and coerce `bin` to an ASCII string, but that\n    // will break if there is a null char\n    term = new Term(this._r, {\n      $reql_type$: 'BINARY',\n      data: bin.toString('base64')\n    });\n  }\n  else {\n    term = new Term(this._r);\n    term._query.push(termTypes.BINARY)\n    var args = [new Term(this._r).expr(bin)];\n    term._fillArgs(args);\n  }\n  return term;\n}\n\nTerm.prototype.js = function(arg, options) {\n  this._noPrefix(this, 'js');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'js', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.JAVASCRIPT)\n  var args = [new Term(this._r).expr(arg)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.coerceTo = function(type) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'coerceTo', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.COERCE_TO)\n  var args = [this, new Term(this._r).expr(type)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.typeOf = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'typeOf', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.TYPE_OF);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.info = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'info', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.INFO);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.json = function(json) {\n  this._noPrefix(this, 'json');\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'info', this);\n  }\n  /*\n  if ((/\\\\u0000/.test(json)) || (/\\0/.test(json))) {\n    this._error = new Error.ReqlDriverError('The null character is currently not supported by RethinkDB');\n  }\n  */\n  var term = new Term(this._r);\n  term._query.push(termTypes.JSON);\n\n  var args = [new Term(this._r).expr(json)];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.http = function(url, options) {\n  this._noPrefix(this, 'http');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'http', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.HTTP);\n  var args = [new Term(this._r).expr(url)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'timeout')\n        && (key !==  'attempts')\n        && (key !==  'redirects')\n        && (key !==  'verify')\n        && (key !==  'resultFormat')\n        && (key !==  'method')\n        && (key !==  'auth')\n        && (key !==  'params')\n        && (key !==  'header')\n        && (key !==  'data')\n        && (key !==  'page')\n        && (key !==  'pageLimit')\n        && (key !==  '')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `http`. Available options are attempts <number>, redirects <number>, verify <boolean>, resultFormat: <string>, method: <string>, auth: <object>, params: <object>, header: <string>, data: <string>, page: <string/function>, pageLimit: <number>');\n      }\n    });\n\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.uuid = function(str) {\n  this._noPrefix(this, 'uuid');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.UUID)\n\n  if (str !== undefined) {\n    var args = [new Term(this._r).expr(str)];\n    term._fillArgs(args);\n  }\n  return term;\n}\n\n\nTerm.prototype.circle = function(center, radius, options) {\n  var self = this;\n\n  // Arity check is done by r.circle\n  self._noPrefix(self, 'circle');\n  var term = new Term(self._r);\n  term._query.push(termTypes.CIRCLE);\n  var args = [new Term(self._r).expr(center), new Term(self._r).expr(radius)];\n  term._fillArgs(args);\n\n  if (helper.isPlainObject(options)) {\n    // There is no need to translate here\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'numVertices') && (key !== 'geoSystem') && (key !== 'unit') && (key !== 'fill')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `circle`', self._query, 'Available options are numVertices <number>, geoSsystem <string>, unit <string> and fill <bool>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\nTerm.prototype.distance = function(geometry, options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 1, 2, 'distance', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.DISTANCE);\n  var args = [self, new Term(self._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'geoSystem') && (key !== 'unit')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are geoSystem <string>, unit <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\nTerm.prototype.fill = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'fill', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.FILL);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.geojson = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'geojson', this);\n  }\n  this._noPrefix(this, 'geojson');\n  var term = new Term(this._r);\n  term._query.push(termTypes.GEOJSON);\n  var args = [new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.toGeojson = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toGeojson', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_GEOJSON);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.getIntersecting = function(geometry, options) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'getIntersecting', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.GET_INTERSECTING);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if (key !== 'index') {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `distance`', self._query, 'Available options are index <string>');\n      }\n    });\n    term._query.push(new Term(this._r).expr(translateOptions(options))._query);\n  }\n  return term;\n}\n\nTerm.prototype.getNearest = function(geometry, options) {\n  var self = this;\n  if (self._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arity(_args, 2, 'getNearest', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.GET_NEAREST);\n  var args = [self, new Term(self._r).expr(geometry)];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'index') && (key !== 'maxResults') && (key !== 'maxDist') && (key !== 'unit') && (key !== 'geoSystem')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `getNearest`', self._query, 'Available options are index <string>, maxResults <number>, maxDist <number>, unit <string>, geoSystem <string>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n  return term;\n\n}\n\nTerm.prototype.includes = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'includes', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.INCLUDES);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.intersects = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'intersects', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.INTERSECTS);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.line = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  // Arity check is done by r.line\n  this._noPrefix(this, 'line');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.LINE);\n\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.point = function(longitude, latitude) {\n  // Arity check is done by r.point\n  this._noPrefix(this, 'point');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.POINT);\n  var args = [new Term(this._r).expr(longitude), new Term(this._r).expr(latitude)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.polygon = function() {\n  var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n  // Arity check is done by r.polygon\n  this._noPrefix(this, 'polygon');\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.POLYGON);\n\n  var args = [];\n  for(var i=0; i<_args.length; i++) {\n    args.push(new Term(this._r).expr(_args[i]))\n  }\n  term._fillArgs(args);\n\n  return term;\n}\n\nTerm.prototype.polygonSub = function(geometry) {\n  if (this._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 1, 'polygonSub', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.POLYGON_SUB);\n  var args = [this, new Term(this._r).expr(geometry)];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.range = function(start, end) {\n  this._noPrefix(this, 'range');\n  if (this._fastArityRange(arguments.length, 1, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arityRange(_args, 1, 2, 'r.range', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.RANGE);\n  var args = [];\n  args.push(new Term(this._r).expr(start));\n  if (end !== undefined) {\n    args.push(new Term(this._r).expr(end));\n  }\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toJsonString = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'toJSON', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.TO_JSON_STRING);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.toJSON = Term.prototype.toJsonString;\n\nTerm.prototype.config = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'config', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.CONFIG);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.status = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'status', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.STATUS);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\n\nTerm.prototype.wait = function(options) {\n  var self = this;\n  if (self._fastArityRange(arguments.length, 0, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arityRange(_args, 0, 1, 'wait', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.WAIT);\n  var args = [self];\n  term._fillArgs(args);\n  if (helper.isPlainObject(options)) {\n    helper.loopKeys(options, function(obj, key) {\n      if ((key !== 'waitFor') && (key !== 'timeout')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `wait`', self._query, 'Available options are waitFor: <string>, timeout: <number>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(options))._query);\n  }\n\n  return term;\n}\n\nTerm.prototype.reconfigure = function(config) {\n  var self = this;\n  if (self._fastArity(arguments.length, 1) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    self._arity(_args, 1, 'reconfigure', self);\n  }\n  var term = new Term(self._r);\n  term._query.push(termTypes.RECONFIGURE);\n\n  var args = [this];\n  term._fillArgs(args);\n  if (helper.isPlainObject(config)) {\n    helper.loopKeys(config, function(obj, key) {\n      if ((key !== 'shards') && (key !== 'replicas') &&\n        (key !== 'dryRun') && (key !== 'primaryReplicaTag') &&\n        (key !== 'nonvotingReplicaTags') && (key !== 'emergencyRepair')) {\n        throw new Error.ReqlDriverError('Unrecognized option `'+key+'` in `reconfigure`', self._query, 'Available options are shards: <number>, replicas: <number>, primaryReplicaTag: <object>, dryRun <boolean>, emergencyRepair: <string>, nonvotingReplicaTags: <array<string>>');\n      }\n    });\n    term._query.push(new Term(self._r).expr(translateOptions(config))._query);\n  }\n  else {\n    throw new Error.ReqlDriverError('First argument of `reconfigure` must be an object');\n  }\n  return term;\n}\n\nTerm.prototype.rebalance = function() {\n  if (this._fastArity(arguments.length, 0) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 0, 'rebalance', this);\n  }\n  var term = new Term(this._r);\n  term._query.push(termTypes.REBALANCE);\n  var args = [this];\n  term._fillArgs(args);\n  return term;\n}\nTerm.prototype.grant = function(name, access) {\n  if (this._fastArity(arguments.length, 2) === false) {\n    var _len = arguments.length;var _args = new Array(_len); for(var _i = 0; _i < _len; _i++) {_args[_i] = arguments[_i];}\n    this._arity(_args, 2, 'grant', this);\n  }\n\n  var term = new Term(this._r);\n  term._query.push(termTypes.GRANT)\n  var args = [this, new Term(this._r).expr(name), new Term(this._r).expr(access)];\n  term._fillArgs(args);\n  return term;\n}\n\n\nTerm.prototype.then = function(resolve, reject) {\n  return this.run().then(resolve, reject);\n}\nTerm.prototype.error = function(reject) {\n  return this.run().error(reject);\n}\nTerm.prototype.catch = function(reject) {\n  return this.run().catch(reject);\n}\nTerm.prototype.finally = function(handler) {\n  return this.run().finally(handler);\n}\nTerm.prototype.delay = function(msecs) {\n  return this.run().delay(msecs);\n}\n\nTerm.prototype.toString = function() {\n  return Error.generateBacktrace(this._query, 0, null, [], {indent: 0, extra: 0}).str;\n}\n\nTerm.prototype._wrap = function() {\n  var self = this;\n  if (helper.hasImplicit(this._query)) {\n    if (this._query[0] === termTypes.ARGS) {\n      throw new Error.ReqlDriverError('Implicit variable `r.row` cannot be used inside `r.args`')\n    }\n    //Must pass at least one variable to the function or it won't accept r.row\n    return new Term(this._r).expr(function(doc) { return self; })\n  }\n  else {\n    return self;\n  }\n}\n\nTerm.prototype._fillArgs = function(args) {\n  var foundError = false;\n  var internalArgs = [];\n  for(var i=0; i<args.length; i++) {\n  if (args[i] instanceof Term) {\n    internalArgs.push(args[i]._query);\n    if (!foundError && (args[i]._error != null)) {\n    this._error = args[i]._error;\n    this._frames = args[i]._frames;\n    this._frames.unshift(i);\n    foundError = true;\n    }\n  }\n  else {\n    internalArgs.push(args[i]);\n  }\n  }\n  this._query.push(internalArgs);\n  return this;\n}\n\nTerm.prototype._translateArgs = {\n  returnChanges: 'return_changes',\n  includeInitial: 'include_initial',\n  primaryKey: 'primary_key',\n  readMode: 'read_mode',\n  nonAtomic: 'non_atomic',\n  leftBound: 'left_bound',\n  rightBound: 'right_bound',\n  defaultTimezone: 'default_timezone',\n  noReply: 'noreply',\n  resultFormat: 'result_format',\n  pageLimit: 'page_limit',\n  arrayLimit: 'array_limit',\n  numVertices: 'num_vertices',\n  geoSystem: 'geo_system',\n  maxResults: 'max_results',\n  maxDist: 'max_dist',\n  dryRun: 'dry_run',\n  waitFor: 'wait_for',\n  includeStates: 'include_states',\n  primaryReplicaTag: 'primary_replica_tag',\n  emergencyRepair: 'emergency_repair',\n  minBatchRows: 'min_batch_rows',\n  maxBatchRows: 'max_batch_rows',\n  maxBatchBytes: 'max_batch_bytes',\n  maxBatchSeconds: 'max_batch_seconds',\n  firstBatchScaledownFactor: 'first_batch_scaledown_factor',\n  includeOffsets: 'include_offsets',\n  includeTypes: 'include_types',\n  finalEmit: 'final_emit'\n}\nfunction translateOptions(options) {\n  var translatedOpt = {};\n  helper.loopKeys(options, function(options, key) {\n    var keyServer = Term.prototype._translateArgs[key] || key;\n    translatedOpt[keyServer] = options[key];\n  });\n  return translatedOpt;\n}\nTerm.prototype._setNestingLevel = function(nestingLevel) {\n  Term.prototype._nestingLevel = nestingLevel;\n}\nTerm.prototype._setArrayLimit = function(arrayLimit) {\n  Term.prototype._arrayLimit = arrayLimit;\n}\n\n\nTerm.prototype._noPrefix = function(term, method) {\n  if ((!Array.isArray(term._query)) || (term._query.length > 0)) {\n    throw new Error.ReqlDriverError('`'+method+'` is not defined', term._query);\n  }\n}\nTerm.prototype._arityRange = function(args, min, max, method, term) {\n  var foundArgs = false;\n  if (args.length < min) {\n    for(var i=0; i<args.length; i++) {\n      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n        foundArgs = true;\n        break;\n      }\n    }\n    if (foundArgs === false) {\n      throw new Error.ReqlDriverError('`'+method+'` takes at least '+min+' argument'+((min>1)?'s':'')+', '+args.length+' provided', term._query);\n    }\n  }\n  else if (args.length > max) {\n    for(var i=0; i<args.length; i++) {\n      if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n        foundArgs = true;\n        break;\n      }\n    }\n    if (foundArgs === false) {\n      throw new Error.ReqlDriverError('`'+method+'` takes at most '+max+' argument'+((max>1)?'s':'')+', '+args.length+' provided', term._query);\n    }\n  }\n}\nTerm.prototype._arity = function(args, num, method, term) {\n  var foundArgs = false;\n  for(var i=0; i<args.length; i++) {\n    if ((args[i] instanceof Term) && (args[i]._query[0] === termTypes.ARGS)) {\n      foundArgs = true;\n      break;\n    }\n  }\n  if (foundArgs === false) {\n    throw new Error.ReqlDriverError('`'+method+'` takes '+num+' argument'+((num>1)?'s':'')+', '+args.length+' provided', term._query);\n  }\n}\n// Cheap arity check. If it fails, return false, and then we are expected to call _arity/_arityRange\nTerm.prototype._fastArity = function(len, num) {\n  return (len === num);\n}\nTerm.prototype._fastArityRange = function(len, min, max) {\n  return ((len >= min) && (len <= max));\n}\n\n\n// Datums\nfunction Func(r, func) {\n  // We can retrieve the names of the arguments with\n  // func.toString().match(/\\(([^\\)]*)\\)/)[1].split(/\\s*,\\s*/)\n\n  var term = new Term(r);\n  term._query.push(termTypes.FUNC);\n  var args = [];\n  var argVars = [];\n  var argNums = [];\n\n  for(var i=0; i<func.length; i++) {\n    argVars.push(new Var(r, r.nextVarId));\n    argNums.push(r.nextVarId);\n\n    if (r.nextVarId === 9007199254740992) { // That seems like overdoing it... but well maybe...\n      r.nextVarId = 0;\n    }\n    else {\n      r.nextVarId++;\n    }\n  }\n\n  var body = func.apply(func, argVars)\n  if (body === undefined) throw new Error.ReqlDriverError('Anonymous function returned `undefined`. Did you forget a `return`? In:\\n'+func.toString(), this._query);\n  body = new Term(r).expr(body);\n  args.push(new Term(r).expr(argNums));\n  args.push(body);\n\n  term._fillArgs(args);\n\n  return term;\n}\nFunc.prototype.nextVarId = 1;\n\nfunction Var(r, id) {\n  var term = new Term(r);\n  term._query.push(termTypes.VAR)\n  term._query.push([new Term(r).expr(id)._query])\n  return term;\n}\n\nmodule.exports = Term;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/writable_stream.js":"var Writable = require('stream').Writable;\nvar Cursor = require(__dirname+'/cursor.js');\nvar util = require('util');\n\n// Experimental, but should work fine.\nfunction WritableStream(table, options, connection) {\n  this._table = table;\n  this._options = options;\n  this._cache = [];\n  this._pendingCallback = null;\n  this._inserting = false;\n  this._delayed = false;\n  this._connection = connection;\n  this._highWaterMark = options.highWaterMark || 100;\n\n  this._insertOptions = {};\n  this._insertOptions.durability = options.durability || 'hard';\n  this._insertOptions.conflict = options.conflict || 'error';\n\n  // Internal option to run some tests\n  if (options.debug === true) {\n    this._sequence = [];\n  }\n\n  Writable.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n  this._i = 0;\n};\nutil.inherits(WritableStream, Writable);\n\nWritableStream.prototype._write = function(value, encoding, done) {\n  this._i++;\n  this._cache.push(value);\n  this._next(value, encoding, done);\n}\n\n// Everytime we want to insert but do not have a full buffer,\n// we recurse with setImmediate to give a chance to the input\n// stream to push a few more elements\nWritableStream.prototype._next = function(value, encoding, done) {\n  var self = this;\n  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {\n    // There's more data to buffer\n    if (this._cache.length < this._highWaterMark) {\n      this._delayed = false;\n      // Call done now, and more data will be put in the cache\n      done();\n    }\n    else {\n      if (this._inserting === false) {\n        if (this._delayed === true) {\n          this._delayed = false;\n          // We have to flush\n          this._insert();\n          // Fill the buffer while we are inserting data\n          done();\n        }\n        else {\n          var self = this;\n          this._delayed = true;\n          setImmediate(function() {\n            self._next(value, encoding, done);\n          })\n        }\n\n      }\n      else {\n        this._delayed = false;\n        // to call when we are dong inserting to keep buffering\n        this._pendingCallback = done;\n      }\n    }\n  }\n  else { // We just pushed the last element in the internal buffer\n    if (this._inserting === false) {\n      if (this._delayed === true) {\n        this._delayed = false;\n        // to call when we are dong inserting to maybe flag the end\n        // We cannot call done here as we may be inserting the last batch\n        this._pendingCallback = done;\n        this._insert();\n      }\n      else {\n        var self = this;\n        this._delayed = true;\n        setImmediate(function() {\n          self._next(value, encoding, done);\n        })\n      }\n    }\n    else {\n      this._delayed = false;\n      // We cannot call done here as we may be inserting the last batch\n      //this._pendingCallback = done;\n      this._pendingCallback = function() {\n        self._next(value, encoding, done);\n      };\n    }\n  }\n}\n\nWritableStream.prototype._insert = function() {\n  var self = this;\n  self._inserting = true;\n\n  var cache = self._cache;\n  self._cache = [];\n\n  if (Array.isArray(self._sequence)) {\n    self._sequence.push(cache.length);\n  }\n\n  self._table.insert(cache, self._insertOptions).run(self._connection).then(function(result) {\n    self._inserting = false;\n    if (result.errors > 0) {\n      self._inserting = false;\n      self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));\n    }\n    if (typeof self._pendingCallback === 'function') {\n      var pendingCallback = self._pendingCallback;\n      self._pendingCallback = null;\n      pendingCallback();\n    }\n    return null;\n  }).error(function(error) {\n    self._inserting = false;\n    self.emit('error', error);\n  });\n}\n\n\nmodule.exports = WritableStream;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/transform_stream.js":"var Transform = require('stream').Transform;\nvar Cursor = require(__dirname+'/cursor.js');\nvar util = require('util');\n\n// Experimental, but should work fine.\nfunction TransformStream(table, options, connection) {\n  this._table = table;\n  this._r = table._r;\n  this._options = options;\n  this._cache = [];\n  this._pendingCallback = null;\n  this._ended = false;\n  this._inserting = false;\n  this._delayed = false;\n  this._connection = connection;\n  this._highWaterMark = options.highWaterMark || 100;\n  this._insertOptions = {};\n  this._insertOptions.durability = options.durability || 'hard';\n  this._insertOptions.conflict = options.conflict || 'error';\n  this._insertOptions.returnChanges = options.returnChanges || true;\n\n  // Internal option to run some tests\n  if (options.debug === true) {\n    this._sequence = [];\n  }\n\n  Transform.call(this, {\n    objectMode: true,\n    highWaterMark: this._highWaterMark\n  });\n};\nutil.inherits(TransformStream, Transform);\n\nTransformStream.prototype._transform = function(value, encoding, done) {\n  this._cache.push(value);\n  this._next(value, encoding, done);\n}\n\n// Everytime we want to insert but do not have a full buffer,\n// we recurse with setImmediate to give a chance to the input\n// stream to push a few more elements\nTransformStream.prototype._next = function(value, encoding, done) {\n  if ((this._writableState.lastBufferedRequest != null) && (this._writableState.lastBufferedRequest.chunk !== value)) {\n    // There's more data to buffer\n    if (this._cache.length < this._highWaterMark) {\n      this._delayed = false;\n      // Call done now, and more data will be put in the cache\n      done();\n    }\n    else {\n      if (this._inserting === false) {\n        if (this._delayed === true) {\n          // We have to flush\n          this._delayed = false;\n          this._insert();\n          // Fill the buffer while we are inserting data\n          done();\n        }\n        else {\n          var self = this;\n          this._delayed = true;\n          setImmediate(function() {\n            self._next(value, encoding, done);\n          })\n        }\n\n      }\n      else {\n        // to call when we are dong inserting to keep buffering\n        this._pendingCallback = done;\n      }\n    }\n  }\n  else { // We just pushed the last element in the internal buffer\n    if (this._inserting === false) {\n      if (this._delayed === true) {\n        this._delayed = false;\n        // to call when we are dong inserting to maybe flag the end\n        this._insert();\n        // We can call done now, because we have _flush to close the stream\n        done();\n      }\n      else {\n        var self = this;\n        this._delayed = true;\n        setImmediate(function() {\n          self._next(value, encoding, done);\n        })\n      }\n    }\n    else {\n      this._delayed = false;\n      // There is nothing left in the internal buffer\n      // But something is already inserting stuff.\n      if (this._cache.length < this._highWaterMark-1) {\n        // Call done, to attempt to buffer more\n        // This may trigger _flush\n        //this._pendingCallback = done;\n        done();\n      }\n      else {\n        this._pendingCallback = done;\n      }\n    }\n  }\n}\n\nTransformStream.prototype._insert = function() {\n  var self = this;\n  self._inserting = true;\n\n  var cache = self._cache;\n  self._cache = [];\n\n  if (Array.isArray(self._sequence)) {\n    self._sequence.push(cache.length);\n  }\n\n  var pendingCallback = self._pendingCallback;\n  self._pendingCallback = null;\n  if (typeof pendingCallback === 'function') {\n    pendingCallback();\n  }\n\n  var query = self._table.insert(cache, self._insertOptions);\n  if (self._options.format === 'primaryKey') {\n    query = query.do(function(result) {\n      return self._r.branch(\n        result('errors').eq(0),\n        self._table.config()('primary_key').do(function(primaryKey) {\n          return result('changes')('new_val')(primaryKey)\n        }),\n        result(self._r.error(result('errors').coerceTo('STRING').add(' errors returned. First error:\\n').add(result('first_error'))))\n      )\n    })\n  }\n\n  query.run(self._connection).then(function(result) {\n    self._inserting = false;\n    if (self._options.format === 'primaryKey') {\n      for(var i=0; i<result.length; i++) {\n        self.push(result[i]);\n      }\n    }\n    else {\n      if (result.errors > 0) {\n        self._inserting = false;\n        self.emit('error', new Error('Failed to insert some documents:'+JSON.stringify(result, null, 2)));\n      }\n      else {\n        if (self._insertOptions.returnChanges === true) {\n          for(var i=0; i<result.changes.length; i++) {\n            self.push(result.changes[i].new_val);\n          }\n        }\n      }\n    }\n\n    pendingCallback = self._pendingCallback\n    self._pendingCallback = null;\n    if (typeof pendingCallback === 'function') {\n      // Mean that we can buffer more\n      pendingCallback();\n    }\n    else if (self._ended !== true) {\n      if (((((self._writableState.lastBufferedRequest === null) ||\n          self._writableState.lastBufferedRequest.chunk === self._cache[self._cache.length-1])))\n        && (self._cache.length > 0)) {\n          self._insert();\n      }\n    }\n    else if (self._ended === true) {\n      if (self._cache.length > 0) {\n        self._insert();\n      }\n      else {\n        if (typeof self._flushCallback === 'function') {\n          self._flushCallback();\n        }\n        self.push(null);\n      }\n    }\n  }).error(function(error) {\n    self._inserting = false;\n    self.emit('error', error);\n  });\n}\n\nTransformStream.prototype._flush = function(done) {\n  this._ended = true;\n  if ((this._cache.length === 0) && (this._inserting === false)) {\n    done();\n  }\n  else { // this._inserting === true\n    if (this._inserting === false) {\n      this._flushCallback = done;\n      this._insert();\n    }\n    else {\n      this._flushCallback = done;\n    }\n  }\n}\n\n\nmodule.exports = TransformStream;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/pool_master.js":"var util = require('util');\nvar events = require('events');\nvar Promise = require('bluebird');\nvar Dequeue = require(__dirname+'/dequeue.js');\nvar Pool = require(__dirname+'/pool.js');\nvar helper = require(__dirname+'/helper.js');\nvar Err = require(__dirname+'/error.js');\nvar UNKNOWN_POOLS = 'unknownPools';\nvar SEPARATOR = 'feedSeparator';\nfunction PoolMaster(r, options) {\n  var self = this;\n  var options = options || {};\n  var lineLength = options.buffer || 50;\n\n  self._r = r;\n  self._line = new Dequeue(lineLength);\n  self._pools = {};\n  self._pools[UNKNOWN_POOLS] = []; // pools for which we do not know the server'id\n  self._healthyPools = [];\n  self._healthy = false;\n  self._init = false;\n  self._index = 0; // next pool to used\n  self._indexUnknown =  0 // next unknown pool to used\n  self._discovery = (typeof options.discovery === 'boolean') ? options.discovery: false; // Whether the pool master is in discovery mode or not\n  //self._refresh = (typeof options.refresh === 'number') ? options.refresh: 1000*60*60; // Refresh rate for the list of servers\n  self._options = options;\n  self._options.buffer = options.buffer || 50;\n  self._options.max = options.max || 1000;\n  self._log = helper.createLogger(self, options.silent || false);\n  self._draining = false;\n  self._numConnections = 0;\n  self._numAvailableConnections = 0;\n  self._hasPrintWarningLocalhost = false;\n  self._feed = null;\n  self._consecutiveFails = -1;\n  self._timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?\n  self._maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError\n\n  //TODO\n  //self._usingPool = true; // If we have used the pool\n  self._seed = 0;\n\n  var pool;\n  if (Array.isArray(options.servers)) {\n    if (options.servers.length > 0) {\n      self._servers = options.servers;\n      for(var i=0; i<options.servers.length; i++) {\n        var settings = self.createPoolSettings(options, options.servers[i], self._log);\n        pool = new Pool(self._r, settings);\n        self._pools[UNKNOWN_POOLS].push(pool);\n        // A pool is considered healthy by default such that people can do\n        // var = require(...)(); query.run();\n        self._healthyPools.push(pool);\n        self.emitStatus()\n      }\n    }\n    else {\n      throw new Err.ReqlDriverError(\"If `servers` is an array, it must contain at least one server\")\n    }\n  }\n  else {\n    self._servers = [{\n      host: options.host || 'localhost',\n      port: options.port || 28015\n    }]\n    var settings = self.createPoolSettings(options, {}, self._log);\n    pool = new Pool(self._r, settings);\n    self._pools[UNKNOWN_POOLS].push(pool);\n    self._healthyPools.push(pool);\n    self.emitStatus()\n  }\n\n  // Initialize all the pools - bind listeners\n  for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {\n    self.initPool(self._pools[UNKNOWN_POOLS][i]);\n  }\n  if ((self._discovery === true)) {\n    self._timeout = setTimeout(function() { self.fetchServers() }, 0);\n  }\n}\nutil.inherits(PoolMaster, events.EventEmitter);\n\nPoolMaster.prototype.getPools = function() {\n  var result = [];\n  helper.loopKeys(this._pools, function(pools, key) {\n    if (key === UNKNOWN_POOLS) {\n      for(var i=0;i<pools[key].length; i++) {\n        result.push(pools[key][i]);\n      }\n    }\n    else {\n      result.push(pools[key]);\n    }\n  });\n  return result;\n}\n\n// Reject all promises in this._line\nPoolMaster.prototype._flushErrors = function() {\n  while(this._line.getLength() > 0) {\n    this._line.shift().reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());\n    this.emit('queueing', this._line.getLength())\n  }\n}\n\nPoolMaster.prototype.getConnection = function() {\n  var self = this;\n  // Find a pool with available connections\n  var result;\n  for(var i=0; i<self._healthyPools.length; i++) {\n    if (self._index >= self._healthyPools.length) {\n      self._index = 0;\n    }\n    if (self._healthyPools[self._index].getAvailableLength() > 0) {\n      result = self._healthyPools[self._index].getConnection();\n    }\n    self._index++;\n    if (self._index === self._healthyPools.length) {\n      self._index = 0;\n    }\n    if (result) {\n      return result;\n    }\n  }\n  if (self._healthyPools.length === 0) {\n    return new Promise(function(resolve, reject) {\n      reject(new Err.ReqlDriverError('None of the pools have an opened connection and failed to open a new one').setOperational());\n    });\n  }\n  else {\n    // All pool are busy, buffer the request\n    return new Promise(function(resolve, reject) {\n      self._line.push({\n        resolve: resolve,\n        reject: reject\n      });\n\n      self.emit('queueing', self._line.getLength())\n      // We could add a condition to be less greedy (for early start)\n      self._expandAll();\n    });\n\n  }\n}\nPoolMaster.prototype._expandAll = function() {\n  for(var i=0; i<this._healthyPools.length; i++) {\n    this._healthyPools[i]._expandBuffer();\n  }\n}\n\n// Fetch all the servers once\nPoolMaster.prototype.handleAllServersResponse = function(servers) {\n  var self = this;\n  if (self._draining === true) {\n    return;\n  }\n  // Fill all the known server from RethinkDB\n  var knownServer = {};\n  for(var i=0; i<servers.length; i++) {\n    var server = servers[i];\n    knownServer[server.id] = {count: 0, server: server};\n    if (self._pools[server.id] === undefined) {\n      // We potentially have a new server in the cluster, or we already have a pool for this server\n      // in one of the UNKNOWN_POOLS\n      var found = false;\n      for(var j=0; j<self._pools[UNKNOWN_POOLS].length; j++) {\n        if (found) break;\n        var pool = self._pools[UNKNOWN_POOLS][j]; \n        // If a pool is created with localhost, it will probably match the first server even though it may not the the one\n        // So it gets an id\n        for(var k=0; k<server.network.canonical_addresses.length; k++) {\n          // Check for the same host (or if they are both localhost) and port\n          if (((server.network.canonical_addresses[k].host === pool.options.connection.host) ||\n               (server.network.hostname === pool.options.connection.host) ||\n            (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) &&\n            helper.localhostAliases.hasOwnProperty(pool.options.connection.host))) &&\n            (server.network.reql_port === pool.options.connection.port)) {\n\n            self._pools[server.id] = self._pools[UNKNOWN_POOLS].splice(j, 1)[0];\n            // We may assign the wrong pool to this server if it's maching on localhost\n            if (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host)) {\n              self._pools[server.id].options.connection.host = helper.getCanonicalAddress(server.network.canonical_addresses).host;\n              self._pools[server.id].drainLocalhost();\n            }\n            found = true;\n            break;\n          }\n        }\n      }\n      if (found === false) {\n        // We just found a new server, let's extract the canonical address and connect to it\n        self.createPool(server);\n      }\n    }\n  } // Each server know has a pool\n\n  // Check if we need to remove pools\n  helper.loopKeys(self._pools, function(pools, key) { // among the pools with a server id\n    if (key !== UNKNOWN_POOLS) {\n      if (knownServer.hasOwnProperty(key) === false) {\n        self.deletePool(key); // We just found a pool that doesn't map to any known RethinkDB server\n      }\n      else {\n        knownServer[key].count++;\n      }\n    }\n  });\n  for(var i=0;i<self._pools[UNKNOWN_POOLS].length; i++) {\n    // These pools does not match any server returned by RethinkDB.\n    var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];\n    self._log('Removing pool connected to: '+pool.getAddress())\n    pool.drain().then(function() {\n      pool.removeAllListeners();\n    }).error(function(error) {\n      self._log('Pool connected to: '+self._pools[UNKNOWN_POOLS][i].getAddress()+' could not be properly drained.')\n      self._log(error.message);\n      self._log(error.stack);\n    });\n  }\n}\n\n// Create the settings for a given pool. Merge the global options + the servers's one.\nPoolMaster.prototype.createPoolSettings = function(globalOptions, serverOptions, log) {\n  var settings = {};\n  var numServers = Array.isArray(globalOptions.servers) ? globalOptions.servers.length: 1;\n  helper.loopKeys(globalOptions, function(options, key) {\n    if ((key === 'buffer') || (key === 'max')) {\n      settings[key] = Math.ceil(options[key]/numServers);\n      settings[key] = Math.ceil(options[key]/numServers);\n    }\n    else if (key !== 'servers') {\n      settings[key] = options[key];\n    }\n  });\n  if (serverOptions) {\n    helper.loopKeys(serverOptions, function(options, key) {\n      settings[key] = options[key];\n    });\n  }\n  settings._log = log;\n  return settings;\n}\n\n// Create a new pool\nPoolMaster.prototype.createPool = function(server) {\n  var self = this;\n  var address = helper.getCanonicalAddress(server.network.canonical_addresses);\n  var settings = self.createPoolSettings(self._options, {\n    port: server.network.reql_port,\n    host: address.host\n  }, self._log);\n  var pool = new Pool(self._r, settings);\n  self._pools[server.id] = pool\n  self.initPool(pool);\n  self._healthyPools.push(pool);\n  self.emitStatus()\n  self.resetBufferParameters();\n}\n\n// Delete a known pool\nPoolMaster.prototype.deletePool = function(key) {\n  var self = this;\n  var pool = self._pools[key];\n  self._log('Removing pool connected to: '+pool.getAddress())\n  pool.drain().then(function() {\n    pool.removeAllListeners();\n  }).error(function(error) {\n    self._log('Pool connected to: '+self._pools[key].getAddress()+' could not be properly drained.')\n    self._log(error.message);\n    self._log(error.stack);\n  });\n  delete self._pools[key];\n  self.resetBufferParameters();\n}\n\n//  Create the feed on server_status and bind the listener to the feed\nPoolMaster.prototype.fetchServers = function(useSeeds) {\n  var self = this;\n  var query = self._r.db('rethinkdb').table('server_status')\n      .union([SEPARATOR])\n      .union(self._r.db('rethinkdb').table('server_status').changes())\n  // In case useSeeds is true, we rotate through all the seeds + the pool master\n  if (!useSeeds || self._seed === self._servers.length) {\n    if (useSeeds && self._seed === self._servers.length) {\n      // We increase the back off only when we went through all the seeds\n      self._consecutiveFails++;\n    }\n\n    self._seed = 0;\n    var promise = query.run({cursor: true})\n  }\n  else {\n    var settings = self._servers[self._seed];\n    self._seed++;\n    var promise = self._r.connect(settings).then(function(connection) {\n      return query.run(connection, {cursor: true})\n    });\n  }\n  promise.then(function(feed) {\n    if (self._draining === true) {\n      // There is no need to close the feed here as we'll close the connections\n      return feed.close();\n    }\n    self._feed = feed;\n    var initializing = true;\n    var servers = [];\n    feed.each(function(err, change) {\n      if (err) {\n        self._log('The changefeed on server_status returned an error: '+err.toString());\n        // We have to refetch everything as the server that was serving the feed may\n        // have died.\n        if (!self._draining) {\n          setTimeout(function() {\n            self.fetchServers();\n          }, 0); // Give a timeout to let the driver clean the pools\n        }\n        return;\n      }\n      if (initializing === true) {\n        if (change === SEPARATOR) {\n          initializing = false;\n          self.handleAllServersResponse(servers);\n          // Rerun the whole query after to make sure that a change did not skip/sneak between the union. As long\n          // as RethinkDB does not provide initial results\n          setTimeout(function() {\n            self._r.db('rethinkdb').table('server_status').run({cursor: false}).then(function(servers) {\n              self.handleAllServersResponse(servers);\n            }).error(function(error) {\n              self._log('Fail to retrieve a second copy of server_status');\n              //TODO Retry\n            });\n          }, 1000);\n        }\n        else {\n          servers.push(change);\n        }\n        return;\n      }\n\n      if (change.new_val !== null && change.old_val === null) {\n        // New server\n        self.createPool(change.new_val);\n      }\n      else if (change.new_val === null && change.old_val !== null) {\n        // A server was removed\n        var server = change.old_val;\n        if (self._pools[server.id] != null) {\n          self.deletePool(server.id);\n        }\n        else {\n          var found = false;\n          for(var i=0; i<self._pools[UNKNOWN_POOLS].length; i++) {\n            if (((server.network.canonical_addresses[k].host === self._pools[UNKNOWN_POOLS][i].options.connection.host) ||\n              (helper.localhostAliases.hasOwnProperty(server.network.canonical_addresses[k].host) && (helper.localhostAliases.hasOwnProperty(self._pools[UNKNOWN_POOLS][i].options.connection.host)))) &&\n              (server.network.reql_port === self._pools[UNKNOWN_POOLS][i].options.connection.port)) {\n              found = true;\n\n              (function (pool) {\n                self._log('Removing pool connected to: '+pool.getAddress())\n                var pool = self._pools[UNKNOWN_POOLS].splice(i, 1)[0];\n                pool.drain().then(function() {\n                  pool.removeAllListeners();\n                }).error(function(error) {\n                  if (self._options.silent !== true) {\n                    self._log('Pool connected to: '+pool.getAddress()+' could not be properly drained.')\n                    self._log(error.message);\n                    self._log(error.stack);\n                  }\n                });\n              })(self._pools[UNKNOWN_POOLS][i]);\n              break;\n            }\n          }\n        }\n        if (found === false) {\n          self._log('A server was removed but no pool for this server exists...')\n        }\n      }\n      // We ignore this change since this it doesn't affect whether the server\n      // is available or not.\n      // else if (change.new_val !== null && change.old_val !== null) {}\n    });\n    return null;\n  }).error(function(error) {\n    self._log('Could not retrieve the data from server_status: '+JSON.stringify(error));\n    \n    var timeout;\n    if (self._consecutiveFails === -1) {\n      timeout = 0;\n    }\n    else {\n      timeout = (1<<Math.min(self._maxExponent, self._consecutiveFails))*self._timeoutError;\n    }\n    setTimeout(function() {\n      self.fetchServers(true);\n    }, timeout);\n  });\n}\n\n// Bind listeners on the pools\nPoolMaster.prototype.initPool = function(pool) {\n  var self = this;\n\n  pool.on('size-diff', function(diff) {\n    self._numConnections += diff;\n    self.emit('size', self._numConnections)\n  });\n  pool.on('available-size-diff', function(diff) {\n    self._numAvailableConnections += diff;\n    self.emit('available-size', self._numAvailableConnections)\n  });\n\n  pool.on('new-connection', function() {\n    if (self._line.getLength() > 0) {\n      var p = self._line.shift();\n      this.getConnection().then(p.resolve).error(p.reject);\n      self.emit('queueing', self._line.getLength())\n    }\n  });\n  pool.on('not-empty', function() {\n    if (self._draining === false) {\n      var found = false;\n      for(var i=0; i<self._healthyPools.length; i++) {\n        if (self._healthyPools[i] === this) {\n          self._healthyPools.length;\n          found = true;\n          break;\n        }\n      }\n      if (found === false) {\n        self._healthyPools.push(this);\n        self.emitStatus()\n        self.resetBufferParameters();\n      }\n    }\n  });\n  pool.on('empty', function() {\n    // A pool that become empty is considered unhealthy\n    for(var i=0; i<self._healthyPools.length; i++) {\n      if (self._healthyPools[i] === this) {\n        self._healthyPools.splice(i, 1);\n        self.emitStatus()\n        break;\n      }\n    }\n    if (self._healthyPools.length === 0) {\n      self._flushErrors();\n    }\n\n    self.resetBufferParameters();\n  });\n  pool.on('draining', function() {\n    for(var i=0; i<self._healthyPools.length; i++) {\n      if (self._healthyPools[i] === this) {\n        self._healthyPools.splice(i, 1);\n        self.emitStatus()\n        break;\n      }\n    }\n\n    if (self._healthyPools === 0) {\n      self._flushErrors();\n    }\n  });\n}\n\nPoolMaster.prototype.getNumConnections = function() {\n  var sum = 0;\n  for(var i=0; i<this._healthyPools.length; i++) {\n    sum += this._healthyPools[i].getLength();\n  }\n  return sum;\n}\nPoolMaster.prototype.getNumAvailableConnections = function() {\n  var sum = 0;\n  for(var i=0; i<this._healthyPools.length; i++) {\n    sum += this._healthyPools[i].getAvailableLength();\n  }\n  return sum;\n}\n\n// Reset buffer and max for each pool\nPoolMaster.prototype.resetBufferParameters = function() {\n  var max = Math.floor(this._options.max/this._healthyPools.length)\n  var buffer = Math.floor(this._options.buffer/this._healthyPools.length)\n  for(var i=0; i<this._healthyPools.length; i++) {\n    if (this._healthyPools[i].getLength() > max) {\n      this._healthyPools[i]._extraConnections = this._healthyPools[i].getLength()-max;\n    }\n    else {\n      this._healthyPools[i]._extraConnections = 0;\n    }\n    this._healthyPools[i].options.max = max\n    this._healthyPools[i].options.buffer = buffer;\n  }\n}\n\nPoolMaster.prototype.getLength = function() {\n  return this._numConnections;\n}\nPoolMaster.prototype.getAvailableLength = function() {\n  return this._numAvailableConnections;\n}\n\nPoolMaster.prototype.drain = function() {\n  this.emit('draining');\n  if (this._discovery === true) {\n    this._discovery = false;\n    if (this._feed != null) {\n      this._feed.close();\n    }\n  }\n  this._draining = true;\n  var promises = [];\n  var pools = this.getPools();\n  for(var i=0; i<pools.length; i++) {\n    promises.push(pools[i].drain());\n  }\n  this._healthyPools = [];\n  var self = this;\n  return Promise.all(promises).then(function() {\n    for(var i=0; i<pools.length; i++) {\n      pools[i].removeAllListeners();\n    }\n  }).error(function(error) {\n    if (self._options.silent !== true) {\n      self._log('Failed to drain all the pools:');\n      self._log(error.message);\n      self._log(error.stack);\n    }\n  });\n}\n\n// Emit the healthy event with a boolean indicating whether the pool master\n// is healthy or not\nPoolMaster.prototype.emitStatus = function() {\n  var healthy = this._healthyPools.length !== 0;\n  if (this._healthy !== healthy) {\n    this._healthy = healthy;\n    this.emit('healthy', healthy)\n  }\n}\n\nmodule.exports = PoolMaster;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/dequeue.js":"// Implement a dequeue with a circular buffer\n// The buffer can expand but currently doesn't automatically shrink\n// as it is not a desired behavior. We may want to explicitly resize it though.\nfunction Dequeue(size) {\n  this.start = 0;\n  this.end = 0;\n\n  size = size || 50;\n  this.buffer = new Array(size);\n}\nDequeue.prototype.get = function(index) {\n  if (this.start+index > this.buffer.length) {\n    return this.buffer[this.start+index-this.buffer.length]\n  }\n  else {\n    return this.buffer[this.start+index]\n  }\n}\n\nDequeue.prototype.toArray = function(index) {\n  var result = [];\n  for(var i=0; i<this.getLength(); i++) {\n    result.push(this.get(i));\n  }\n  return result;\n}\n\nDequeue.prototype.delete = function(index) {\n  var current, next;\n  if (this.start+index >= this.buffer.length) {\n    current = this.start+index-this.buffer.length;\n    next = this.start+index-this.buffer.length+1;\n  }\n  else {\n    current = this.start+index;\n    next = this.start+index+1;\n  }\n\n  for(var i=index; i<(this.buffer.length-index); i++) {\n    if (next === this.buffer.length) next = 0;\n    if (current === this.buffer.length) current = 0;\n\n    this.buffer[current] = this.buffer[next];\n    current++;\n    next++;\n  }\n\n  this.end--;\n  if (this.end < 0) this.end = this.buffer.length-1\n}\n\nDequeue.prototype.push = function(element) {\n  // push on this.end and then increase this.end\n  // this.end should NEVER be equal to this.buffer.length\n  this.buffer[this.end] = element;\n  this.end++;\n  if (this.end === this.buffer.length) this.end = 0;\n\n  if (this.start === this.end) {\n    // Resize\n    var previousBuffer = this.buffer;\n\n    this.buffer = new Array(previousBuffer.length*2);\n\n    var i, k = 0;\n    for(i=this.start; i<previousBuffer.length; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    for(i=0; i<this.start; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    this.start = 0;\n    this.end = previousBuffer.length;\n  }\n}\n\nDequeue.prototype.pop = function(element) {\n  //TODO: Decrease size when possible/needed? This may not be\n  //something we really need/want\n  // Return the element in this.end-1\n  if (this.getLength() > 0) {\n    var pos = this.end-1;\n    if (pos < 0) pos = this.buffer.length-1;\n    this.end = pos;\n    var result = this.buffer[pos];\n    this.buffer[pos] = undefined;\n    return result;\n  }\n  else {\n    return undefined\n  }\n}\n\nDequeue.prototype.unshift = function(element) {\n  // push on this.start-1 and then decrease this.start.\n  // this.end should NEVER be equal to this.buffer.length\n\n  var pos = this.start-1;\n  if (pos < 0) pos = this.buffer.length-1;\n\n  this.buffer[pos] = element;\n  this.start = pos;\n\n  if (this.start === this.end) {\n    //Resize\n    var previousBuffer = this.buffer;\n\n    this.buffer = new Array(previousBuffer.length*2);\n\n    var i, k = 0;\n    for(i=this.start; i<previousBuffer.length; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    for(i=0; i<this.start; i++) {\n      this.buffer[k++] = previousBuffer[i];\n    }\n    this.start = 0;\n    this.end = previousBuffer.length;\n  }\n}\n\nDequeue.prototype.shift = function() {\n  // Return the element in this.start\n\n  if (this.getLength() > 0) {\n    var result = this.buffer[this.start];\n    this.buffer[this.start] = undefined;\n    this.start++;\n    if (this.start === this.buffer.length) this.start = 0;\n    return result;\n  }\n}\n\nDequeue.prototype.getLength = function() {\n  if (this.start <= this.end) {\n    return this.end-this.start;\n  }\n  else {\n    return this.buffer.length-(this.start-this.end);\n  }\n}\n\nmodule.exports = Dequeue;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/lib/pool.js":"var Promise = require('bluebird');\nvar Dequeue = require(__dirname+'/dequeue.js');\nvar helper = require(__dirname+'/helper.js');\nvar Err = require(__dirname+'/error.js');\nvar events = require('events');\nvar util = require('util');\n\nfunction Pool(r, options) {\n  this._r = r;\n\n  if (!helper.isPlainObject(options)) options = {};\n  this.options = {};\n  this.options.max = options.max || 1000; // 4000 is about the maximum the kernel can take\n  var buffer = (typeof options.buffer === 'number') ? options.buffer : 50;\n  this.options.buffer = (buffer < this.options.max) ? buffer : this.options.max;\n  this.options.timeoutError = options.timeoutError || 1000; // How long should we wait before recreating a connection that failed?\n  this.options.timeoutGb = options.timeoutGb || 60*60*1000; // Default timeout for TCP connection is 2 hours on Linux, we time out after one hour.\n  this.options.maxExponent = options.maxExponent || 6; // Maximum timeout is 2^maxExponent*timeoutError\n\n  this.options.silent = options.silent || false;\n\n  this.options.connection = {\n    host: options.host || this._r._host,\n    port: options.port || this._r._port,\n    db: options.db || this._r._db,\n    timeout: options.timeout || this._r._timeoutConnect,\n    authKey: options.authKey,\n    user: options.user,\n    password: options.password,\n    cursor: options.cursor || false,\n    stream: options.stream || false,\n    ssl: options.ssl || false,\n    pingInterval: options.pingInterval || this._r._pingInterval\n  }\n  this._log = options._log;\n\n  this._pool = new Dequeue(this.options.buffer+1);\n  this._draining = false;\n  this._drainingHandlers = null; // Store the resolve/reject methods once draining is called\n  this._localhostToDrain = 0; // number of connections to \"localhost\" to remove\n  this._connectionToReplace = 0; // number of connections to \"localhost\" to remove\n\n  this._numConnections = 0;\n  this._openingConnections = 0; // Number of connections being opened\n  this._consecutiveFails = 0;   // In slow growth, the number of consecutive failures to open a connection\n  this._slowGrowth = false;     // Opening one connection at a time\n  this._slowlyGrowing = false;  // The next connection to be returned is one opened in slowGrowth mode\n  this._extraConnections = 0; // Number of extra connections being opened that we should eventually close\n\n  this._empty = true;\n\n  var self = this;\n  // So we can let the pool master bind listeners\n  setTimeout(function() {\n    if (self._draining === false) {\n      for(var i=0; i<self.options.buffer; i++) {\n        if (self.getLength() < self.options.max) {\n          self.createConnection();\n        }\n      }\n    }\n  }, 0);\n  this.id = Math.floor(Math.random()*100000);\n  this._log('Creating a pool connected to '+this.getAddress());\n}\n\nutil.inherits(Pool, events.EventEmitter);\n/*\n * Events:\n *  - draining // when `drain` is called\n *  - queueing(size of the queue) // the number of queries being beffered changed\n *  - size(number of connections) // the size of the pool changed\n *  - available-size(available size) // the number of AVAILABLE conncetions of the pool changed\n */\n\nPool.prototype.getConnection = function() {\n  var self = this;\n  var p = new Promise(function(resolve, reject) {\n    if (self._draining === true) {\n      return reject(new Err.ReqlDriverError('The pool is being drained').setOperational());\n    }\n\n    var connection = self._pool.pop();\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', -1);\n\n    if (connection) {\n      clearTimeout(connection.timeout);\n      resolve(connection);\n    }\n    else {\n      if ((self._numConnections === 0) && (self._slowGrowth === true)) {\n        // If the server is down we do not want to buffer the queries\n        return reject(new Err.ReqlDriverError('The pool does not have any opened connections and failed to open a new one').setOperational());\n      }\n    }\n\n    if (self._slowGrowth === false) {\n      self._expandBuffer();\n    }\n\n  });\n  return p;\n};\n\nPool.prototype._decreaseNumConnections = function() {\n  this._numConnections--;\n  this.emit('size', this._numConnections)\n  this.emit('size-diff', -1)\n  if ((this._drainingHandlers !== null) && (this._numConnections === 0)) {\n    this._drainingHandlers.resolve();\n  }\n  // We do not check for this._empty === false because we want to emit empty if the pool\n  // tries to connect to an unavailable server (such that the master can remove it from the\n  // healthy pool\n  if (this._numConnections === 0) {\n    this._empty = true;\n    this.emit('empty');\n  }\n}\nPool.prototype._increaseNumConnections = function() {\n  this._numConnections++;\n  this.emit('size', this._numConnections)\n  this.emit('size-diff', 1)\n}\n\n\nPool.prototype.putConnection = function(connection) {\n  var self = this;\n  if (connection.end === false) {\n    // Temporary attempt to fix #192 - this should not happen.\n    return;\n  }\n  if (self._empty === true) {\n    self._empty = false;\n    // We emit not-empty only we have at least one opened connection\n    self.emit('not-empty');\n  }\n  if ((self._localhostToDrain > 0) && (helper.localhostAliases.hasOwnProperty(connection.host))) {\n    self._localhostToDrain--;\n    connection.close();\n    clearTimeout(connection.timeout);\n    self.createConnection();\n  }\n  else if (self._drainingHandlers !== null) {\n    connection.close();\n    clearTimeout(connection.timeout);\n    if (self.getLength() === 0) {\n      self._drainingHandlers.resolve();\n    }\n  }\n  else if (self._extraConnections > 0) {\n    self._extraConnections--;\n    connection.close().error(function(error) {\n      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));\n    });\n    clearTimeout(connection.timeout);\n  }\n  /*\n  // We let the pool garbage collect these connections\n  else if (self.getAvailableLength()+1 > self.options.buffer) { // +1 for the connection we may put back\n    // Note that because we have available connections here, the pool master has no pending\n    // queries.\n    connection.close().error(function(error) {\n      self._log('Fail to properly close a connection. Error:'+JSON.stringify(error));\n    });\n    clearTimeout(connection.timeout);\n  }\n  */\n  else {\n    self._pool.push(connection);\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', 1);\n    self.emit('new-connection', connection);\n\n    clearTimeout(connection.timeout);\n    var timeoutCb = function() {\n      if (self._pool.get(0) === connection) {\n        if (self._pool.getLength() > self.options.buffer) {\n          self._pool.shift().close();\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n        }\n        else {\n          connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n        }\n      }\n      else {\n        // This should technically never happens\n        connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n      }\n    }\n    connection.timeout = setTimeout(timeoutCb, self.options.timeoutGb);\n  }\n};\n\nPool.prototype.createConnection = function() {\n  var self = this;\n  self._increaseNumConnections();\n  self._openingConnections++;\n\n  self.emit('creating-connection', self);\n  if (self._draining === true) {\n    return; // Do not create a new connection if we are draining the pool.\n  }\n\n  return self._r.connect(self.options.connection).then(function(connection) {\n    self.emit('created-connection', self);\n\n    self._openingConnections--;\n\n    if ((self._slowlyGrowing === false) && (self._slowGrowth === true) && (self._openingConnections === 0)) {\n      self._consecutiveFails++;\n      self._slowlyGrowing = true;\n      self.timeoutReconnect = setTimeout(function() {\n        self.createConnection();\n        //self._expandBuffer();\n      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);\n    }\n    // Need another flag\n    else if ((self._slowlyGrowing === true) && (self._slowGrowth === true) && (self._consecutiveFails > 0)) {\n      self._log('Exiting slow growth mode');\n      self._consecutiveFails = 0;\n      self._slowGrowth = false;\n      self._slowlyGrowing = false;\n      self._aggressivelyExpandBuffer();\n    }\n\n\n\n    connection.on('error', function(error) {\n      // We are going to close connection, but we don't want another process to use it before\n      // So we remove it from the pool now (if it's inside)\n      self._log('Error emitted by a connection: '+JSON.stringify(error));\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n      // We want to make sure that it's not going to try to reconnect\n      clearTimeout(connection.timeout);\n\n      // Not sure what happened here, so let's be safe and close this connection.\n      connection.close().then(function() {\n        return self._expandBuffer();\n      }).error(function(e) {\n        // We failed to close this connection, but we removed it from the pool... so err, let's just ignore that.\n        self._expandBuffer();\n      });\n    });\n    connection.on('end', function(e) {\n      // The connection was closed by the server, let's clean...\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n\n      clearTimeout(connection.timeout);\n      self._decreaseNumConnections();\n      self._expandBuffer();\n    });\n    connection.on('timeout', function() {\n      for(var i=0; i<self.getAvailableLength(); i++) {\n        if (self._pool.get(i) === this) {\n          self._pool.delete(i);\n          self.emit('available-size', self._pool.getLength());\n          self.emit('available-size-diff', -1);\n          break;\n        }\n      }\n\n      clearTimeout(connection.timeout);\n      self._decreaseNumConnections();\n      self._expandBuffer();\n    });\n    connection.on('release', function() {\n      if (this._isOpen()) self.putConnection(this);\n    });\n    self.putConnection(connection);\n    return null;\n  }).error(function(error) {\n    // We failed to create a connection, we are now going to create connections one by one\n    self._openingConnections--;\n    self._decreaseNumConnections();\n\n    self._slowGrowth = true;\n    if (self._slowlyGrowing === false) {\n      self._log('Entering slow growth mode');\n    }\n    self._slowlyGrowing = true;\n\n    // Log an error\n    self._log('Fail to create a new connection for the connection pool. Error:'+JSON.stringify(error));\n\n    if (self._openingConnections === 0) {\n      self._consecutiveFails++;\n      self.timeoutReconnect = setTimeout(function() {\n        //self._expandBuffer();\n        self.createConnection();\n      }, (1<<Math.min(self.options.maxExponent, self._consecutiveFails))*self.options.timeoutError);\n    }\n  })\n};\n\nPool.prototype._aggressivelyExpandBuffer = function() {\n  for(var i=0; i<this.options.buffer; i++) {\n    this._expandBuffer();\n  }\n}\nPool.prototype._expandBuffer = function() {\n  if ((this._draining === false) &&\n      (this._pool.getLength() < this.options.buffer+this._localhostToDrain) &&\n      (this._numConnections < this.options.max+this._localhostToDrain)) {\n    this.createConnection();\n  }\n}\n\nPool.prototype.getLength = function() {\n  return this._numConnections;\n}\nPool.prototype.getAvailableLength = function() {\n  return this._pool.getLength();\n}\n\nPool.prototype.setOptions = function(options) {\n  if (helper.isPlainObject(options)) {\n    for(var key in options) {\n      this.options[key] = options[key];\n    }\n  }\n  return this.options;\n}\nPool.prototype.drainLocalhost = function() {\n  var self = this;\n  // All the connections are to localhost, let's create new ones (not to localhost)\n  self._connectionToReplace = self._numConnections;\n  ;\n  for(var i=0, numConnections=self._numConnections; i<numConnections; i++) {\n    self.createConnection().finally(function() {\n      self._localhostToDrain++;\n      self._connectionToReplace--;\n      if ((self._connectionToReplace === 0) && (self._localhostToDrain > 0)) {\n        var len = self._pool.getLength();\n        for(var j=0; j<len; j++) {\n          if (self._localhostToDrain === 0) {\n            break;\n          }\n          var _connection = self._pool.shift();\n          if (helper.localhostAliases.hasOwnProperty(_connection.host)) {\n            self._localhostToDrain--;\n            _connection.close();\n            clearTimeout(_connection.timeout);\n          }\n          else {\n            self._pool.push(_connection);\n          }\n        }\n      }\n\n    });\n  }\n}\n\nPool.prototype.drain = function() {\n  var self = this;\n  self._draining = true;\n  self._log('Draining the pool connected to '+this.getAddress());\n  self.emit('draining');\n  var p = new Promise(function(resolve, reject) {\n    var connection = self._pool.pop();\n    self.emit('available-size', self._pool.getLength());\n    self.emit('available-size-diff', -1);\n    while(connection) {\n      connection.close();\n      clearTimeout(connection.timeout);\n      connection = self._pool.pop();\n    }\n    if (self.timeoutReconnect !== undefined) {\n      clearTimeout(self.timeoutReconnect);\n      self.timeoutReconnect = null;\n    }\n    if (self.getLength() === 0) {\n      resolve();\n    }\n    else {\n      self._drainingHandlers = {\n        resolve: resolve,\n        reject: reject\n      }\n    }\n  });\n  return p;\n}\n\n\nPool.prototype.getAddress = function() {\n  return this.options.connection.host+':'+this.options.connection.port;\n}\nmodule.exports = Pool;\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/browserify.js":"var browserify = require('browserify');\nvar fs = require('fs');\n\nvar REQUIRE_FILES = [\n  'connection.js',\n  'cursor.js',\n  'dequeue.js',\n  'error.js',\n  'helper.js',\n  'metadata.js',\n  'pool.js',\n  'pool_master.js',\n  'protodef.js',\n  'stream.js',\n  'term.js',\n  'transform_stream.js',\n  'writable_stream.js'\n];\n\nvar b = browserify('./lib/')\nb.add('./lib/index.js')\nfor(var i=0; i<REQUIRE_FILES.length; i++) {\n  b.require('./lib/'+REQUIRE_FILES[i], {expose: './lib/'+REQUIRE_FILES[i]})\n}\nb.require('./lib/index.js', {expose: 'rethinkdbdash'})\nb.bundle(function(err, result) {\n  if (err) {\n    console.log(err);\n    return;\n  }\n  fs.writeFileSync('./rethinkdbdash.js', result);\n});\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/tool/generateTest.js":"var Promise = require('bluebird');\nvar config = require(__dirname+'/../test/config.js');\nvar r = require(__dirname+'/../lib')(config);\nvar util = require(__dirname+'/../test/util/common.js');\nvar assert = require('assert');\n\n\n\n\nvar dbName = util.uuid()\nvar tableName = util.uuid()\n\nvar query; // without `.run()`\n//query = 'r.table(\"foo\").add(1).add(1).add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").map( function(doc) { return r.expr([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).map(function(test) { return test(\"b\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").mul(test(\"b\")).merge({ firstName: \"xxxxxx\", lastName: \"yyyy\", email: \"xxxxx@yyyy.com\", phone: \"xxx-xxx-xxxx\" }); }).add(2).map(function(doc) { return doc.add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\").add(\"hello-super-long-string\").add(\"another-long-string\").add(\"one-last-string\") }); })';\nquery = 'r.db(dbName).table(tableName).rebalance().do(function(x) { return x.add(4) })';\nPromise.coroutine(function* () {\n  try {\n    yield r.dbCreate(dbName).run();\n    yield r.db(dbName).tableCreate(tableName).run();\n\n    var result = yield eval(query).run();\n    throw new Error(\"Should have thrown an error\");\n  }\n  catch(e) {\n    console.log(e.message);\n    console.log('')\n    console.log('')\n    console.log('')\n    console.log('/*');\n    console.log('Frames:');\n    console.log(e.frames);\n    console.log('');\n    console.log('Error:');\n    console.log(e.message.trim());\n    console.log('*/');\n    console.log('It(\\'Test backtrace for '+query+'\\', function* (done) {')\n    console.log('    try {');\n    console.log('        r.nextVarId=1;');\n    console.log('        yield '+query+'.run()');\n    console.log('        done(new Error(\"Should have thrown an error\"))');\n    console.log('    }');\n    console.log('    catch(e) {');\n    //console.log('        if (e.message.replace(/var_[0-9]+/, \"VAR\") === '+JSON.stringify(e.message.replace(/var_[0-9]+/, \"VAR\")).replace('\\\\\"'+dbName+'\\\\\"', '\\\\\"\"+dbName+\"\\\\\"').replace('\\\\\"'+tableName+'\\\\\"', '\"+tableName+\"')+') {');\n    console.log('        if (e.message === '+JSON.stringify(e.message).replace(new RegExp(dbName, \"g\"), '\"+dbName+\"').replace(new RegExp(tableName, \"g\"), '\"+tableName+\"')+') {');\n    console.log('            done()');\n    console.log('        }');\n    console.log('        else {');\n    console.log('            done(e);');\n    console.log('        }');\n    console.log('    }');\n    console.log('})');\n\n    r.getPoolMaster().drain();\n  }\n})()\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/test/config.js":"module.exports = {\n  host: process.env['WERCKER_RETHINKDB_HOST'] || 'localhost',\n  port: parseInt(process.env['WERCKER_RETHINKDB_PORT'], 10) || 28015,\n  authKey: '',\n  buffer: 2,\n  max: 5,\n  fake_server: {\n    host: process.env['WERCKER_RETHINKDB_HOST'] || 'localhost',\n    port: parseInt(process.env['WERCKER_RETHINKDB_PORT'], 10)+1 || 28016,\n  },\n  discovery: false,\n  silent: true\n}\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/test/util/common.js":"var Promise = require('bluebird');\nPromise.coroutine.addYieldHandler(function(yieldedValue) {\n  if (Array.isArray(yieldedValue)) return Promise.all(yieldedValue);\n});\n\n\nfunction s4() {\n  return Math.floor((1+Math.random())*0x10000).toString(16).substring(1);\n};\n\nfunction uuid() {\n  return s4()+s4()+s4()+s4()+s4()+s4()+s4()+s4();\n}\n\nfunction It(testName, generatorFn) {\n  it(testName, function(done) {\n    Promise.coroutine(generatorFn)(done);\n  })\n}\nfunction sleep(timer) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(resolve, timer);\n  });\n}\n\nmodule.exports.uuid = uuid\nmodule.exports.It = It\nmodule.exports.sleep = sleep\n","/home/travis/build/npmtest/node-npmtest-rethinkdbdash/node_modules/rethinkdbdash/tool/ulimit.js":"var assert = require('assert');\n\n// Set ulimit -n 50 for this test\nvar maxOpenFiles = 50;\n\nvar r = require('../lib/')({\n  min: maxOpenFiles-20,\n  max: 2*maxOpenFiles\n});\n\n\nvar Promise = require('bluebird');\n\n\n(function() {\n\n  var promises = [];\n  for(var i=0; i<70;i++) {\n    promises.push(r.expr(1).run());\n  }\n\n  setTimeout(function() {\n    Promise.all(promises).then(function() {\n      console.log('Sending second batch');\n      console.log(r.getPool().getLength());\n      assert(r.getPool().getLength() < maxOpenFiles);\n\n\n      promises = [];\n      for(var i=0; i<70;i++) {\n        promises.push(r.expr(1).run());\n      }\n      return Promise.all(promises);\n    }).then(function() {\n      console.log(\"test done\");\n    }).error(function(err) {\n      console.log(\"Error\");\n      console.log(err);\n    });\n  }, 10000)\n  setTimeout(function() {\n    Promise.all(promises).then(function() {\n      console.log('Sending second batch');\n      console.log(r.getPool().getLength());\n      assert(r.getPool().getLength() < maxOpenFiles);\n\n\n      promises = [];\n      for(var i=0; i<70;i++) {\n        promises.push(r.expr(1).run());\n      }\n      return Promise.all(promises);\n    }).then(function() {\n      console.log(\"test done\");\n    }).error(function(err) {\n      console.log(\"Error\");\n      console.log(err);\n    });\n  }, 20000)\n\n})();\n"}